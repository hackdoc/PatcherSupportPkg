// -*- Metal -*-
//===-- metal_texture -----------------------------------------------------===//
// Copyright (c) 2014-2020 Apple Inc. All rights reserved
//===----------------------------------------------------------------------===//

#ifndef __METAL_TEXTURE
#define __METAL_TEXTURE

#if defined(__HAVE_ARRAY__)
#include <metal_array>
#endif
#if defined(__HAVE_IMAGEBLOCKS__)
#include <metal_imageblocks>
#endif

#pragma METAL internals : enable
namespace metal
{
struct _sampler_state
{
  uchar s_address_v;
  uchar t_address_v;
  uchar r_address_v;
  uchar mag_filter_v;
  uchar min_filter_v;
  uchar mip_filter_v;
  uchar coord_v;
  uchar compare_func_v;
  uchar max_anisotropy_v;
  float lod_clamp_min_v;
  float lod_clamp_max_v;
  uchar border_color_v;
  uchar reduction_v;
};

enum class s_address
{
  clamp_to_zero = __METAL_ADDRESS_CLAMP_TO_ZERO__,
  clamp_to_edge = __METAL_ADDRESS_CLAMP_TO_EDGE__,
  repeat = __METAL_ADDRESS_REPEAT__,
  mirrored_repeat = __METAL_ADDRESS_MIRRORED_REPEAT__,
#if defined(__HAVE_BORDER_COLOR__)
  clamp_to_border = __METAL_ADDRESS_CLAMP_TO_BORDER__
#endif
};

enum class t_address
{
  clamp_to_zero = __METAL_ADDRESS_CLAMP_TO_ZERO__,
  clamp_to_edge = __METAL_ADDRESS_CLAMP_TO_EDGE__,
  repeat = __METAL_ADDRESS_REPEAT__,
  mirrored_repeat = __METAL_ADDRESS_MIRRORED_REPEAT__,
#if defined(__HAVE_BORDER_COLOR__)
  clamp_to_border = __METAL_ADDRESS_CLAMP_TO_BORDER__
#endif
};

enum class r_address
{
  clamp_to_zero = __METAL_ADDRESS_CLAMP_TO_ZERO__,
  clamp_to_edge = __METAL_ADDRESS_CLAMP_TO_EDGE__,
  repeat = __METAL_ADDRESS_REPEAT__,
  mirrored_repeat = __METAL_ADDRESS_MIRRORED_REPEAT__,
#if defined(__HAVE_BORDER_COLOR__)
  clamp_to_border = __METAL_ADDRESS_CLAMP_TO_BORDER__
#endif
};

enum class address
{
  clamp_to_zero = __METAL_ADDRESS_CLAMP_TO_ZERO__,
  clamp_to_edge = __METAL_ADDRESS_CLAMP_TO_EDGE__,
  repeat = __METAL_ADDRESS_REPEAT__,
  mirrored_repeat = __METAL_ADDRESS_MIRRORED_REPEAT__,
#if defined(__HAVE_BORDER_COLOR__)
  clamp_to_border = __METAL_ADDRESS_CLAMP_TO_BORDER__
#endif
};

enum class mag_filter
{
  nearest = __METAL_MAG_FILTER_NEAREST__,
  linear = __METAL_MAG_FILTER_LINEAR__,
#if defined(__HAVE_BICUBIC_FILTERING__)
  bicubic = __METAL_MAG_FILTER_BICUBIC__
#endif
};

enum class min_filter
{
  nearest = __METAL_MIN_FILTER_NEAREST__,
  linear = __METAL_MIN_FILTER_LINEAR__,
#if defined(__HAVE_BICUBIC_FILTERING__)
  bicubic = __METAL_MIN_FILTER_BICUBIC__
#endif
};

enum class filter
{
  nearest = __METAL_FILTER_NEAREST__,
  linear = __METAL_FILTER_LINEAR__,
#if defined(__HAVE_BICUBIC_FILTERING__)
  bicubic = __METAL_FILTER_BICUBIC__
#endif
};

enum class mip_filter
{
  none = __METAL_MIP_FILTER_NONE__,
  nearest = __METAL_MIP_FILTER_NEAREST__,
  linear = __METAL_MIP_FILTER_LINEAR__
};

enum class coord
{
  normalized = __METAL_COORD_NORMALIZED__,
  pixel = __METAL_COORD_PIXEL__
};

enum class compare_func
{
#if defined(__HAVE_NONE_COMPARE_FUNCTION__)
  none = __METAL_COMPARE_FUNC_NONE__,
#endif
  less = __METAL_COMPARE_FUNC_LESS__,
  less_equal = __METAL_COMPARE_FUNC_LESS_EQUAL__,
  greater = __METAL_COMPARE_FUNC_GREATER__,
  greater_equal = __METAL_COMPARE_FUNC_GREATER_EQUAL__,
  equal = __METAL_COMPARE_FUNC_EQUAL__,
  not_equal = __METAL_COMPARE_FUNC_NOT_EQUAL__,
#if defined(__HAVE_ALWAYS_NEVER_COMPARE_FUNCTION__)
  always = __METAL_COMPARE_FUNC_ALWAYS__,
  never = __METAL_COMPARE_FUNC_NEVER__
#endif
};

#if defined(__HAVE_ANISOTROPY_LOD_MIN_MAX__)
struct max_anisotropy
{
  METAL_FUNC constexpr explicit max_anisotropy(int v) thread
      : value(v)
  {
  }

private:
  uchar value;

  friend METAL_FUNC constexpr _sampler_state _build_sampler_state(_sampler_state, max_anisotropy);
};

struct lod_clamp
{
  METAL_FUNC constexpr explicit lod_clamp(float min, float max) thread
      : min(min),
        max(max)
  {
  }

private:
  float min;
  float max;

  friend METAL_FUNC constexpr _sampler_state _build_sampler_state(_sampler_state, lod_clamp);
};
#endif

#if defined(__HAVE_BORDER_COLOR__)
enum class border_color
{
  transparent_black = __METAL_BORDER_COLOR_TRANSPARENT_BLACK__,
  opaque_black = __METAL_BORDER_COLOR_OPAQUE_BLACK__,
  opaque_white = __METAL_BORDER_COLOR_OPAQUE_WHITE__
};
#endif

#if defined(__HAVE_SAMPLER_REDUCTION__)
enum class reduction
{
  weighted_average = __METAL_REDUCTION_WEIGHTED_AVERAGE__,
  minimum = __METAL_REDUCTION_MINIMUM__,
  maximum = __METAL_REDUCTION_MAXIMUM__
};
#endif

struct bias
{
  METAL_FUNC constexpr bias(float value) thread
      : value(value)
  {
  }
  float value;
};

template <typename T>
struct _is_sampler_init_type : bool_constant<is_same<T, s_address>::value ||
                                             is_same<T, t_address>::value ||
                                             is_same<T, r_address>::value ||
                                             is_same<T, address>::value ||
                                             is_same<T, mag_filter>::value ||
                                             is_same<T, min_filter>::value ||
                                             is_same<T, filter>::value ||
                                             is_same<T, mip_filter>::value ||
                                             is_same<T, coord>::value ||
                                             is_same<T, compare_func>::value ||
#if defined(__HAVE_ANISOTROPY_LOD_MIN_MAX__)
                                             is_same<T, max_anisotropy>::value ||
                                             is_same<T, lod_clamp>::value ||
#endif
#if defined(__HAVE_BORDER_COLOR__)
                                             is_same<T, border_color>::value ||
#endif
#if defined(__HAVE_SAMPLER_REDUCTION__)
                                             is_same<T, reduction>::value ||
#endif
                                             false>
{
};

constexpr METAL_FUNC _sampler_state _build_sampler_state(_sampler_state s, s_address addr)
{
  return
  {
    static_cast<uchar>(addr), s.t_address_v, s.r_address_v,
        s.mag_filter_v, s.min_filter_v, s.mip_filter_v,
        s.coord_v, s.compare_func_v,
        s.max_anisotropy_v, s.lod_clamp_min_v, s.lod_clamp_max_v,
        s.border_color_v, s.reduction_v,
  };
}
constexpr METAL_FUNC _sampler_state _build_sampler_state(_sampler_state s, t_address addr)
{
  return
  {
    s.s_address_v, static_cast<uchar>(addr), s.r_address_v,
        s.mag_filter_v, s.min_filter_v, s.mip_filter_v,
        s.coord_v, s.compare_func_v,
        s.max_anisotropy_v, s.lod_clamp_min_v, s.lod_clamp_max_v,
        s.border_color_v, s.reduction_v,
  };
}
constexpr METAL_FUNC _sampler_state _build_sampler_state(_sampler_state s, r_address addr)
{
  return
  {
    s.s_address_v, s.t_address_v, static_cast<uchar>(addr),
        s.mag_filter_v, s.min_filter_v, s.mip_filter_v,
        s.coord_v, s.compare_func_v, s.max_anisotropy_v,
        s.lod_clamp_min_v, s.lod_clamp_max_v,
        s.border_color_v, s.reduction_v,
  };
}
constexpr METAL_FUNC _sampler_state _build_sampler_state(_sampler_state s, address addr)
{
  return
  {
    static_cast<uchar>(addr), static_cast<uchar>(addr), static_cast<uchar>(addr),
        s.mag_filter_v, s.min_filter_v, s.mip_filter_v,
        s.coord_v, s.compare_func_v,
        s.max_anisotropy_v, s.lod_clamp_min_v, s.lod_clamp_max_v,
        s.border_color_v, s.reduction_v,
  };
}
constexpr METAL_FUNC _sampler_state _build_sampler_state(_sampler_state s, mag_filter flt)
{
  return
  {
    s.s_address_v, s.t_address_v, s.r_address_v,
        static_cast<uchar>(flt), s.min_filter_v, s.mip_filter_v,
        s.coord_v, s.compare_func_v,
        s.max_anisotropy_v, s.lod_clamp_min_v, s.lod_clamp_max_v,
        s.border_color_v, s.reduction_v,
  };
}
constexpr METAL_FUNC _sampler_state _build_sampler_state(_sampler_state s, min_filter flt)
{
  return
  {
    s.s_address_v, s.t_address_v, s.r_address_v,
        s.mag_filter_v, static_cast<uchar>(flt), s.mip_filter_v,
        s.coord_v, s.compare_func_v,
        s.max_anisotropy_v, s.lod_clamp_min_v, s.lod_clamp_max_v,
        s.border_color_v, s.reduction_v,
  };
}
constexpr METAL_FUNC _sampler_state _build_sampler_state(_sampler_state s, filter flt)
{
  return
  {
    s.s_address_v, s.t_address_v, s.r_address_v,
        static_cast<uchar>(flt), static_cast<uchar>(flt), s.mip_filter_v,
        s.coord_v, s.compare_func_v,
        s.max_anisotropy_v, s.lod_clamp_min_v, s.lod_clamp_max_v,
        s.border_color_v, s.reduction_v,
  };
}
constexpr METAL_FUNC _sampler_state _build_sampler_state(_sampler_state s, mip_filter flt)
{
  return
  {
    s.s_address_v, s.t_address_v, s.r_address_v,
        s.mag_filter_v, s.min_filter_v, static_cast<uchar>(flt),
        s.coord_v, s.compare_func_v,
        s.max_anisotropy_v, s.lod_clamp_min_v, s.lod_clamp_max_v,
        s.border_color_v, s.reduction_v,
  };
}
constexpr METAL_FUNC _sampler_state _build_sampler_state(_sampler_state s, coord c)
{
  return
  {
    s.s_address_v, s.t_address_v, s.r_address_v,
        s.mag_filter_v, s.min_filter_v, s.mip_filter_v,
        static_cast<uchar>(c), s.compare_func_v,
        s.max_anisotropy_v, s.lod_clamp_min_v, s.lod_clamp_max_v,
        s.border_color_v, s.reduction_v,
  };
}
constexpr METAL_FUNC _sampler_state _build_sampler_state(_sampler_state s, compare_func f)
{
  return
  {
    s.s_address_v, s.t_address_v, s.r_address_v,
        s.mag_filter_v, s.min_filter_v, s.mip_filter_v,
        s.coord_v, static_cast<uchar>(f),
        s.max_anisotropy_v, s.lod_clamp_min_v, s.lod_clamp_max_v,
        s.border_color_v, s.reduction_v,
  };
}
#if defined(__HAVE_ANISOTROPY_LOD_MIN_MAX__)
constexpr METAL_FUNC _sampler_state _build_sampler_state(_sampler_state s, max_anisotropy aniso)
{
  return
  {
    s.s_address_v, s.t_address_v, s.r_address_v,
        s.mag_filter_v, s.min_filter_v, s.mip_filter_v,
        s.coord_v, s.compare_func_v,
        aniso.value, s.lod_clamp_min_v, s.lod_clamp_max_v,
        s.border_color_v, s.reduction_v,
  };
}
constexpr METAL_FUNC _sampler_state _build_sampler_state(_sampler_state s, lod_clamp lod)
{
  return
  {
    s.s_address_v, s.t_address_v, s.r_address_v,
        s.mag_filter_v, s.min_filter_v, s.mip_filter_v,
        s.coord_v, s.compare_func_v,
        s.max_anisotropy_v, lod.min, lod.max,
        s.border_color_v, s.reduction_v,
  };
}
#endif
#if defined(__HAVE_BORDER_COLOR__)
constexpr METAL_FUNC _sampler_state _build_sampler_state(_sampler_state s, border_color bc)
{
  return
  {
    s.s_address_v, s.t_address_v, s.r_address_v,
        s.mag_filter_v, s.min_filter_v, s.mip_filter_v,
        s.coord_v, s.compare_func_v,
        s.max_anisotropy_v, s.lod_clamp_min_v, s.lod_clamp_max_v,
        static_cast<uchar>(bc), s.reduction_v,
  };
}
#endif
#if defined(__HAVE_SAMPLER_REDUCTION__)
constexpr METAL_FUNC _sampler_state _build_sampler_state(_sampler_state s, reduction r)
{
  return
  {
    s.s_address_v, s.t_address_v, s.r_address_v,
        s.mag_filter_v, s.min_filter_v, s.mip_filter_v,
        s.coord_v, s.compare_func_v,
        s.max_anisotropy_v, s.lod_clamp_min_v, s.lod_clamp_max_v,
        s.border_color_v, static_cast<uchar>(r),
  };
}
#endif

constexpr METAL_FUNC _sampler_state _get_sampler_state()
{
  return
  {
    __METAL_ADDRESS_CLAMP_TO_EDGE__, __METAL_ADDRESS_CLAMP_TO_EDGE__, __METAL_ADDRESS_CLAMP_TO_EDGE__,
        __METAL_FILTER_NEAREST__, __METAL_FILTER_NEAREST__, __METAL_MIP_FILTER_NONE__,
        __METAL_COORD_NORMALIZED__,
#if defined(__HAVE_ALWAYS_NEVER_COMPARE_FUNCTION__)
        __METAL_COMPARE_FUNC_NEVER__,
#else
        __METAL_COMPARE_FUNC_NONE__,
#endif
        1u, 0.0f, FLT_MAX,
        __METAL_BORDER_COLOR_TRANSPARENT_BLACK__, __METAL_REDUCTION_WEIGHTED_AVERAGE__,
  };
}

template <typename T, typename... Ts>
constexpr METAL_FUNC _sampler_state _get_sampler_state(T t, Ts... ts)
{
  return _build_sampler_state(_get_sampler_state(ts...), t);
}

// Metal 1.1 s2.6: Samplers.
struct sampler
{
#if defined(__HAVE_OPERATOR_ADDRESSOF_DELETED__)
#if !defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread sampler &operator&() const thread = delete;
#endif
#if !defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant sampler &operator&() const constant = delete;
#endif
#endif

public:
  METAL_FUNC constexpr sampler() thread : val(_get_metal_sampler(_get_sampler_state()))
  {
  }
  template <typename... Ts,
            typename = typename enable_if<_conjunction<_is_sampler_init_type<Ts>...>::value>::type>
  METAL_FUNC constexpr sampler(Ts... ts) thread : val(_get_metal_sampler(_get_sampler_state(ts...)))
  {
  }
  METAL_FUNC constexpr sampler() constant : val(_get_metal_sampler(_get_sampler_state()))
  {
  }
  template <typename... Ts,
            typename = typename enable_if<_conjunction<_is_sampler_init_type<Ts>...>::value>::type>
  METAL_FUNC constexpr sampler(Ts... ts) constant : val(_get_metal_sampler(_get_sampler_state(ts...)))
  {
  }
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC constexpr sampler() ray_data : val(_get_metal_sampler(_get_sampler_state()))
  {
  }
  template <typename... Ts,
            typename = typename enable_if<_conjunction<_is_sampler_init_type<Ts>...>::value>::type>
  METAL_FUNC constexpr sampler(Ts... ts) ray_data : val(_get_metal_sampler(_get_sampler_state(ts...)))
  {
  }
#endif

  METAL_FUNC constexpr sampler(const thread sampler &) thread = default;
  METAL_FUNC constexpr sampler(const constant sampler &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC constexpr sampler(const device sampler &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC constexpr sampler(const ray_data sampler &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC constexpr sampler(const object_data sampler &) thread = default;
#endif
  METAL_FUNC constexpr sampler(const thread sampler &) constant = default;
  METAL_FUNC constexpr sampler(const constant sampler &) constant = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC constexpr sampler(const device sampler &) constant = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC constexpr sampler(const ray_data sampler &) constant = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC constexpr sampler(const object_data sampler &) constant = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC constexpr sampler(const thread sampler &) ray_data = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC constexpr sampler(const constant sampler &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC constexpr sampler(const device sampler &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC constexpr sampler(const ray_data sampler &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC constexpr sampler(const object_data sampler &) ray_data = default;
#endif
#endif

#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC thread sampler &operator=(const thread sampler &) thread = default;
#else
  thread sampler &operator=(const thread sampler &) thread = delete;
#endif
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC thread sampler &operator=(const constant sampler &) thread = default;
#else
  thread sampler &operator=(const constant sampler &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC thread sampler &operator=(const device sampler &) thread = default;
#else
  thread sampler &operator=(const device sampler &) thread = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC thread sampler &operator=(const ray_data sampler &) thread = default;
#else
  thread sampler &operator=(const ray_data sampler &) thread = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC thread sampler &operator=(const object_data sampler &) thread = default;
#else
  thread sampler &operator=(const object_data sampler &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC device sampler &operator=(const thread sampler &) device = default;
#else
  device sampler &operator=(const thread sampler &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC device sampler &operator=(const constant sampler &) device = default;
#else
  device sampler &operator=(const constant sampler &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC device sampler &operator=(const device sampler &) device = default;
#else
  device sampler &operator=(const device sampler &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC device sampler &operator=(const ray_data sampler &) device = default;
#else
  device sampler &operator=(const ray_data sampler &) device = delete;
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC device sampler &operator=(const object_data sampler &) device = default;
#else
  device sampler &operator=(const object_data sampler &) device = delete;
#endif
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC ray_data sampler &operator=(const thread sampler &) ray_data = default;
#else
  ray_data sampler &operator=(const thread sampler &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC ray_data sampler &operator=(const constant sampler &) ray_data = default;
#else
  ray_data sampler &operator=(const constant sampler &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC ray_data sampler &operator=(const device sampler &) ray_data = default;
#else
  ray_data sampler &operator=(const device sampler &) ray_data = delete;
#endif
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC ray_data sampler &operator=(const ray_data sampler &) ray_data = default;
#else
  ray_data sampler &operator=(const ray_data sampler &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC ray_data sampler &operator=(const object_data sampler &) ray_data = default;
#else
  ray_data sampler &operator=(const object_data sampler &) ray_data = delete;
#endif
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC object_data sampler &operator=(const thread sampler &) object_data = default;
#else
  object_data sampler &operator=(const thread sampler &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC object_data sampler &operator=(const constant sampler &) object_data = default;
#else
  object_data sampler &operator=(const constant sampler &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC object_data sampler &operator=(const device sampler &) object_data = default;
#else
  object_data sampler &operator=(const device sampler &) object_data = delete;
#endif
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC object_data sampler &operator=(const ray_data sampler &) object_data = default;
#else
  object_data sampler &operator=(const ray_data sampler &) object_data = delete;
#endif
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC object_data sampler &operator=(const object_data sampler &) object_data = default;
#else
  object_data sampler &operator=(const object_data sampler &) object_data = delete;
#endif
#endif

private:
  __metal_sampler_t val;

private:
  static constexpr METAL_FUNC __metal_sampler_t _get_metal_sampler(_sampler_state s)
  {
    return __metal_get_sampler(s.s_address_v, s.t_address_v, s.r_address_v,
                               s.mag_filter_v, s.min_filter_v, s.mip_filter_v,
                               s.coord_v, s.compare_func_v,
                               s.max_anisotropy_v, s.lod_clamp_min_v, s.lod_clamp_max_v,
                               s.border_color_v, s.reduction_v,
                               0.0f
    );
  }

private:
  template <typename T, access a, typename _Enable>
  friend struct _texture1d_sample;
  template <typename T, access a, typename _Enable>
  friend struct _texture1d_array_sample;
  template <typename T, access a, typename _Enable>
  friend struct _texture2d_sample;
  template <typename T, access a, typename _Enable>
  friend struct _texture2d_gather;
  template <typename T, access a, typename _Enable>
  friend struct _texture2d_array_sample;
  template <typename T, access a, typename _Enable>
  friend struct _texture2d_array_gather;
  template <typename T, access a, typename _Enable>
  friend struct _texture3d_sample;
  template <typename T, access a, typename _Enable>
  friend struct _texturecube_sample;
  template <typename T, access a, typename _Enable>
  friend struct _texturecube_gather;
#if defined(__HAVE_TEXTURE_CUBE_ARRAY__)
  template <typename T, access a, typename _Enable>
  friend struct _texturecube_array_sample;
  template <typename T, access a, typename _Enable>
  friend struct _texturecube_array_gather;
#endif
  template <typename T, access a, typename _Enable>
  friend struct _depth2d_sample;
  template <typename T, access a, typename _Enable>
  friend struct _depth2d_gather;
  template <typename T, access a, typename _Enable>
  friend struct _depth2d_array_sample;
  template <typename T, access a, typename _Enable>
  friend struct _depth2d_array_gather;
  template <typename T, access a, typename _Enable>
  friend struct _depthcube_sample;
  template <typename T, access a, typename _Enable>
  friend struct _depthcube_gather;
#if defined(__HAVE_DEPTH_CUBE_ARRAY__)
  template <typename T, access a, typename _Enable>
  friend struct _depthcube_array_sample;
  template <typename T, access a, typename _Enable>
  friend struct _depthcube_array_gather;
#endif
};

template <typename T>
struct _is_color_texture_channel_impl : bool_constant<__is_metal_color_texture_channel(T)>
{
};

template <typename T>
struct is_color_texture_channel : _is_color_texture_channel_impl<remove_cv_t<T>>
{
};
#ifdef __cpp_variable_templates
template <typename T>
constexpr constant bool is_color_texture_channel_v = is_color_texture_channel<T>::value;
#endif

template <typename T>
struct _is_depth_texture_channel_impl : bool_constant<__is_metal_depth_texture_channel(T)>
{
};

template <typename T>
struct is_depth_texture_channel : _is_depth_texture_channel_impl<remove_cv_t<T>>
{
};
#ifdef __cpp_variable_templates
template <typename T>
constexpr constant bool is_depth_texture_channel_v = is_depth_texture_channel<T>::value;
#endif

#if defined(__HAVE_SPARSE_TEXTURES__)
template <typename T, typename _E = typename enable_if<is_color_texture_channel<make_scalar_t<T>>::value || is_depth_texture_channel<make_scalar_t<T>>::value>::type>
struct sparse_color
{
public:
  METAL_FUNC constexpr sparse_color(T value, bool resident) thread
      : color_value(value), from_resident_pages(resident)
  {
  }

  // Indicates whether all memory addressed to retrieve the value was mapped.
  METAL_FUNC constexpr bool resident() const thread
  {
    return from_resident_pages;
  }
  METAL_FUNC constexpr T const value() const thread
  {
    return color_value;
  }

private:
  T color_value;
  ulong from_resident_pages : 1;
  ulong reserved : 63;
};
#endif

struct level
{
  METAL_FUNC constexpr level(float lod) thread
      : lod(lod)
  {
  }
  float lod;
};

#if defined(__HAVE_MIN_LOD_CLAMP__)
struct min_lod_clamp
{
  METAL_FUNC constexpr min_lod_clamp(float value) thread
      : value(value)
  {
  }
  float value;
};
#endif

// To allow level to be used in constant argument checks.
template <>
struct _constarg_traits<level>
{
  constexpr static METAL_INTERNAL bool check(level l)
  {
    return _constarg_traits<float>::check(l.lod);
  }
};

struct gradient2d
{
  METAL_FUNC constexpr gradient2d(float2 dPdx, float2 dPdy) thread
      : dPdx(dPdx), dPdy(dPdy)
  {
  }
  float2 dPdx;
  float2 dPdy;
};

struct gradient3d
{
  METAL_FUNC constexpr gradient3d(float3 dPdx, float3 dPdy) thread
      : dPdx(dPdx), dPdy(dPdy)
  {
  }
  float3 dPdx;
  float3 dPdy;
};

struct gradientcube
{
  METAL_FUNC constexpr gradientcube(float3 dPdx, float3 dPdy) thread
      : dPdx(dPdx), dPdy(dPdy)
  {
  }
  float3 dPdx;
  float3 dPdy;
};

enum class component
{
  x,
  y,
  z,
  w
};

METAL_INTERNAL constexpr bool _is_zero(uint a)
{
  return a == 0;
}
METAL_INTERNAL constexpr bool _is_zero(level a)
{
  return a.lod == 0;
}
#define METAL_ZERO_ARG(A) \
  METAL_ENABLE_IF(_is_zero(A), "'" #A "' argument value must be 0")

#if defined(__HAVE_ZERO_LOD_ARG__)
#define METAL_VALID_LOD_ARG(A) \
  METAL_CONST_ARG(A)           \
  METAL_ZERO_ARG(A)
#else
#define METAL_VALID_LOD_ARG(A)
#endif

#if defined(__HAVE_ZERO_LOD_ARG__)
#define METAL_VALID_LEVEL_ARG(A) \
  METAL_CONST_ARG(A)             \
  METAL_ZERO_ARG(A)
#else
#define METAL_VALID_LEVEL_ARG(A)
#endif

// Metal 1.1 s2.5: Textures.
template <typename T, access a = access::sample, typename _Enable = void>
struct texture1d;
template <typename T, access a = access::sample, typename _Enable = void>
struct texture1d_array;
template <typename T, access a = access::sample, typename _Enable = void>
struct texture2d;
template <typename T, access a = access::sample, typename _Enable = void>
struct texture2d_array;
template <typename T, access a = access::sample, typename _Enable = void>
struct texture3d;
template <typename T, access a = access::sample, typename _Enable = void>
struct texturecube;
#if defined(__HAVE_TEXTURE_CUBE_ARRAY__)
template <typename T, access a = access::sample, typename _Enable = void>
struct texturecube_array;
#endif
template <typename T, access a = access::read, typename _Enable = void>
struct texture2d_ms;
#if defined(__HAVE_TEXTURE_2D_MS_ARRAY__)
template <typename T, access a = access::read, typename _Enable = void>
struct texture2d_ms_array;
#endif
#if defined(__HAVE_TEXTURE_BUFFER__)
template <typename T, access a = access::read, typename _Enable = void>
struct texture_buffer;
#endif
template <typename T, access a = access::sample, typename _Enable = void>
struct depth2d;
template <typename T, access a = access::sample, typename _Enable = void>
struct depth2d_array;
template <typename T, access a = access::sample, typename _Enable = void>
struct depthcube;
#if defined(__HAVE_DEPTH_CUBE_ARRAY__)
template <typename T, access a = access::sample, typename _Enable = void>
struct depthcube_array;
#endif
template <typename T, access a = access::read, typename _Enable = void>
struct depth2d_ms;
#if defined(__HAVE_DEPTH_2D_MS_ARRAY__)
template <typename T, access a = access::read, typename _Enable = void>
struct depth2d_ms_array;
#endif

#if defined(__HAVE_NULL_TEXTURE__)
// Metal 1.2 s5.10.15: Null Texture Functions.
template <typename T, access a> METAL_FUNC bool is_null_texture(texture1d<T, a> tex);
template <typename T, access a> METAL_FUNC bool is_null_texture(texture1d_array<T, a> tex);
template <typename T, access a> METAL_FUNC bool is_null_texture(texture2d<T, a> tex);
template <typename T, access a> METAL_FUNC bool is_null_texture(texture2d_array<T, a> tex);
template <typename T, access a> METAL_FUNC bool is_null_texture(texture3d<T, a> tex);
template <typename T, access a> METAL_FUNC bool is_null_texture(texturecube<T, a> tex);
#if defined(__HAVE_TEXTURE_CUBE_ARRAY__)
template <typename T, access a> METAL_FUNC bool is_null_texture(texturecube_array<T, a> tex);
#endif
template <typename T, access a> METAL_FUNC bool is_null_texture(texture2d_ms<T, a> tex);
#if defined(__HAVE_TEXTURE_2D_MS_ARRAY__)
template <typename T, access a> METAL_FUNC bool is_null_texture(texture2d_ms_array<T, a> tex);
#endif
#if defined(__HAVE_TEXTURE_BUFFER__)
template <typename T, access a> METAL_FUNC bool is_null_texture(texture_buffer<T, a> tex);
#endif
template <typename T, access a> METAL_FUNC bool is_null_texture(depth2d<T, a> tex);
template <typename T, access a> METAL_FUNC bool is_null_texture(depth2d_array<T, a> tex);
template <typename T, access a> METAL_FUNC bool is_null_texture(depthcube<T, a> tex);
#if defined(__HAVE_DEPTH_CUBE_ARRAY__)
template <typename T, access a> METAL_FUNC bool is_null_texture(depthcube_array<T, a> tex);
#endif
template <typename T, access a> METAL_FUNC bool is_null_texture(depth2d_ms<T, a> tex);
#if defined(__HAVE_DEPTH_2D_MS_ARRAY__)
template <typename T, access a> METAL_FUNC bool is_null_texture(depth2d_ms_array<T, a> tex);
#endif
#endif

#if defined(__HAVE_IMAGEBLOCKS__)
template <typename E, typename T>
struct _is_color_texture_imageblock_slice_storage_valid_impl : bool_constant<__is_metal_color_texture_imageblock_slice_storage_valid(E, T)>
{
};

template <typename E, typename T>
struct is_color_texture_imageblock_slice_storage_valid : _is_color_texture_imageblock_slice_storage_valid_impl<remove_cv_t<E>, remove_cv_t<T>>
{
};
#ifdef __cpp_variable_templates
template <typename E, typename T>
constexpr constant bool is_color_texture_imageblock_slice_storage_valid_v = is_color_texture_imageblock_slice_storage_valid<E, T>::value;
#endif
#endif

#if defined(__HAVE_TEXTURE_RELAXED_ORDER_ATOMIC__)
template <typename T>
struct _is_color_texture_atomic_channel_impl : bool_constant<is_same_v<T, int> || is_same_v<T, uint>>
{
};

template <typename T>
struct is_color_texture_atomic_channel : _is_color_texture_atomic_channel_impl<remove_cv_t<T>>
{
};
#ifdef __cpp_variable_templates
template <typename T>
constexpr constant bool is_color_texture_atomic_channel_v = is_color_texture_atomic_channel<T>::value;
#endif
#endif

template <typename T>
METAL_INTERNAL constexpr bool _is_any_of(T)
{
  return false;
}

template <typename T, typename... Ts>
METAL_INTERNAL constexpr bool _is_any_of(T a, T b, Ts... bs)
{
  return a == b || _is_any_of(a, bs...);
}

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__)
#if !defined(__HAVE_INDIRECT_WRITABLE_TEXTURES__)
#define _is_valid_default_construct(_a) _is_any_of(_a, access::read, access::sample)
#elif !defined(__HAVE_TEXTURE_READWRITE__)
#define _is_valid_default_construct(_a) _is_any_of(_a, access::read, access::sample, access::write)
#else
#define _is_valid_default_construct(_a) _is_any_of(_a, access::read, access::sample, access::write, access::read_write)
#endif
#endif

#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
#if !defined(__HAVE_INDIRECT_WRITABLE_TEXTURES__)
#define _is_valid_copy_assign(a) _is_any_of(a, access::read, access::sample)
#elif !defined(__HAVE_TEXTURE_READWRITE__)
#define _is_valid_copy_assign(a) _is_any_of(a, access::read, access::sample, access::write)
#else
#define _is_valid_copy_assign(a) _is_any_of(a, access::read, access::sample, access::write, access::read_write)
#endif
#endif

#define _is_valid_sample(_a) _is_any_of(_a, access::sample)

#if defined(__HAVE_TEXTURE_READWRITE__)
#define _is_valid_read(_a) _is_any_of(_a, access::sample, access::read, access::read_write)
#define _is_valid_write(_a) _is_any_of(_a, access::write, access::read_write)
#else
#define _is_valid_read(_a) _is_any_of(_a, access::sample, access::read)
#define _is_valid_write(_a) _is_any_of(_a, access::write)
#endif

#define _is_valid_gather(_a) _is_any_of(_a, access::sample)

#define _is_valid_ms_access(_a) _is_any_of(_a, access::read)

#define _is_valid_texture_buffer_access(_a) _is_any_of(_a, access::read, access::write, access::read_write)

#define _is_valid_depth_access(_a) _is_any_of(_a, access::sample, access::read)

#if defined(__HAVE_IMAGEBLOCKS__)
#define _is_valid_imageblock_slice_write(_e, _t) (is_color_texture_imageblock_slice_storage_valid_v<_e, _t>)
#endif

#if defined(__HAVE_TEXTURE_RELAXED_ORDER_ATOMIC__)
#define _is_color_texture_atomic_channel_type(_t) (is_color_texture_atomic_channel_v<_t>)
#endif

template <typename _T>
struct _deleted_operators {
#if defined(__HAVE_OPERATOR_ADDRESSOF_DELETED__)
#if !defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread _deleted_operators &operator&() const thread = delete;
#endif
#endif

#if defined(__HAVE_OPERATOR_COMMA_DELETED__)
  const thread _deleted_operators &operator,(const thread _deleted_operators &) const thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device _deleted_operators &operator,(const device _deleted_operators &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant _deleted_operators &operator,(const constant _deleted_operators &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread _deleted_operators &operator,(const thread _deleted_operators &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device _deleted_operators &operator,(const device _deleted_operators &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant _deleted_operators &operator,(const constant _deleted_operators &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread _deleted_operators &operator,(const thread _deleted_operators &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device _deleted_operators &operator,(const device _deleted_operators &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant _deleted_operators &operator,(const constant _deleted_operators &) const constant = delete;
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture1d_sample
{
};

#if defined(__HAVE_TEXTURE_ULONG_COLOR_CHANNEL__)
template <access a>
struct _texture1d_sample<ulong, a, typename enable_if<_is_valid_sample(a)>::type>
{
};
#endif

template <typename T, access a>
struct _texture1d_sample<T, a, typename enable_if<_is_valid_sample(a)>::type>
{
  METAL_FUNC vec<T, 4> sample(sampler s, float coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_sample_texture_1d_t(derived.t, s.val, coord, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool *>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float coord) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_1d_t(derived.t, s.val, coord, false, 0, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float coord) const device
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_sample_texture_1d_t(derived.t, s.val, coord, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool *>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float coord) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_1d_t(derived.t, s.val, coord, false, 0, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_sample_texture_1d_t(derived.t, s.val, coord, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool *>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float coord) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_1d_t(derived.t, s.val, coord, false, 0, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> sample(sampler s, float coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_sample_texture_1d_t(derived.t, s.val, coord, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool *>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float coord) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_1d_t(derived.t, s.val, coord, false, 0, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> sample(sampler s, float coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_sample_texture_1d_t(derived.t, s.val, coord, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool *>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float coord) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_1d_t(derived.t, s.val, coord, false, 0, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture1d_read
{
};

template <typename T, access a>
struct _texture1d_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord, ushort lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_read_texture_1d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort coord, ushort lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint coord, uint lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_read_texture_1d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint coord, uint lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord, ushort lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_read_texture_1d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort coord, ushort lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint coord, uint lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_read_texture_1d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint coord, uint lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord, ushort lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_read_texture_1d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort coord, ushort lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint coord, uint lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_read_texture_1d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint coord, uint lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord, ushort lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_read_texture_1d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort coord, ushort lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint coord, uint lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_read_texture_1d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint coord, uint lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord, ushort lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_read_texture_1d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort coord, ushort lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint coord, uint lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_read_texture_1d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint coord, uint lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture1d_write
{
};

template <typename T, access a>
struct _texture1d_write<T, a, typename enable_if<_is_valid_write(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord, ushort lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    __metal_write_texture_1d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort coord, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord, uint lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    __metal_write_texture_1d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint coord, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord, ushort lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    __metal_write_texture_1d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort coord, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord, uint lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    __metal_write_texture_1d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint coord, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord, ushort lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    __metal_write_texture_1d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort coord, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord, uint lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    __metal_write_texture_1d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint coord, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord, ushort lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    __metal_write_texture_1d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort coord, ushort lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord, uint lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    __metal_write_texture_1d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint coord, uint lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord, ushort lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    __metal_write_texture_1d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort coord, ushort lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord, uint lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    __metal_write_texture_1d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint coord, uint lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
};

#if defined(__HAVE_TEXTURE_RELAXED_ORDER_ATOMIC__)
template <typename T, access a, typename _Enable = void>
struct _texture1d_atomic_load
{
};

template <typename T, access a>
struct _texture1d_atomic_load<T, a, typename enable_if<_is_valid_read(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC vec<T, 4> atomic_load(ushort coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_1d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_1d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(ushort coord) const device
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_1d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint coord) const device
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_1d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(ushort coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_1d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_1d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(ushort coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_1d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_1d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(ushort coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_1d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_1d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture1d_atomic_store
{
};

template <typename T, access a>
struct _texture1d_atomic_store<T, a, typename enable_if<_is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_1d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_1d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort coord) const device
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_1d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint coord) const device
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_1d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_1d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_1d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_1d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_1d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_1d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_1d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture1d_atomic_compare_exchange
{
};

template <typename T, access a>
struct _texture1d_atomic_compare_exchange<T, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC bool atomic_compare_exchange_weak(ushort coord, thread vec<T, 4> *expected, vec<T, 4> desired) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_1d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint coord, thread vec<T, 4> *expected, vec<T, 4> desired) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_1d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(ushort coord, thread vec<T, 4> *expected, vec<T, 4> desired) const device
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_1d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint coord, thread vec<T, 4> *expected, vec<T, 4> desired) const device
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_1d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(ushort coord, thread vec<T, 4> *expected, vec<T, 4> desired) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_1d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint coord, thread vec<T, 4> *expected, vec<T, 4> desired) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_1d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(ushort coord, thread vec<T, 4> *expected, vec<T, 4> desired) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_1d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint coord, thread vec<T, 4> *expected, vec<T, 4> desired) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_1d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(ushort coord, thread vec<T, 4> *expected, vec<T, 4> desired) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_1d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint coord, thread vec<T, 4> *expected, vec<T, 4> desired) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_1d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture1d_atomic_exchange
{
};

template <typename T, access a>
struct _texture1d_atomic_exchange<T, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC vec<T, 4> atomic_exchange(ushort coord, vec<T, 4> desired) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_1d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint coord, vec<T, 4> desired) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_1d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(ushort coord, vec<T, 4> desired) const device
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_1d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint coord, vec<T, 4> desired) const device
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_1d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(ushort coord, vec<T, 4> desired) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_1d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint coord, vec<T, 4> desired) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_1d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(ushort coord, vec<T, 4> desired) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_1d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint coord, vec<T, 4> desired) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_1d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(ushort coord, vec<T, 4> desired) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_1d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint coord, vec<T, 4> desired) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_1d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture1d_atomic_fetch_and
{
};

template <typename T, access a>
struct _texture1d_atomic_fetch_and<T, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture1d_atomic_fetch_and_arith
{
};

template <typename T, access a>
struct _texture1d_atomic_fetch_and_arith<T, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture1d_atomic_modify
{
};

template <access a>
struct _texture1d_atomic_modify<ulong, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a)>::type>
{
  METAL_FUNC void atomic_max(ushort coord, ulong4 operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort coord, ulong4 operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint coord, ulong4 operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint coord, ulong4 operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(ushort coord, ulong4 operand) const device
  {
    const device auto &derived = static_cast<const device texture1d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort coord, ulong4 operand) const device
  {
    const device auto &derived = static_cast<const device texture1d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint coord, ulong4 operand) const device
  {
    const device auto &derived = static_cast<const device texture1d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint coord, ulong4 operand) const device
  {
    const device auto &derived = static_cast<const device texture1d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(ushort coord, ulong4 operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort coord, ulong4 operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint coord, ulong4 operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint coord, ulong4 operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(ushort coord, ulong4 operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort coord, ulong4 operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint coord, ulong4 operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint coord, ulong4 operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(ushort coord, ulong4 operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort coord, ulong4 operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint coord, ulong4 operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint coord, ulong4 operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};
#endif

template <typename T, access a, typename _Enable = void>
struct _texture1d
{
};

template <typename T, access a>
struct _texture1d<T, a, typename enable_if<is_color_texture_channel<T>::value>::type>
  : _deleted_operators<texture1d<T, a>>
  , _texture1d_sample<T, a>
  , _texture1d_read<T, a>
  , _texture1d_write<T, a>
#if defined(__HAVE_TEXTURE_RELAXED_ORDER_ATOMIC__)
  , _texture1d_atomic_load<T, a>
  , _texture1d_atomic_store<T, a>
  , _texture1d_atomic_compare_exchange<T, a>
  , _texture1d_atomic_exchange<T, a>
  , _texture1d_atomic_fetch_and<T, a>
  , _texture1d_atomic_fetch_and_arith<T, a>
  , _texture1d_atomic_modify<T, a>
#endif
{
  METAL_FUNC void fence() thread
  {
    thread auto &derived = static_cast<thread texture1d<T, a> &>(*this);
    __metal_fence_texture_1d_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() device
  {
    device auto &derived = static_cast<device texture1d<T, a> &>(*this);
    __metal_fence_texture_1d_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() constant
  {
    constant auto &derived = static_cast<constant texture1d<T, a> &>(*this);
    __metal_fence_texture_1d_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC void fence() ray_data
  {
    ray_data auto &derived = static_cast<ray_data texture1d<T, a> &>(*this);
    __metal_fence_texture_1d_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC void fence() object_data
  {
    object_data auto &derived = static_cast<object_data texture1d<T, a> &>(*this);
    __metal_fence_texture_1d_t(derived.t);
  }
#endif

  METAL_FUNC uint get_width(uint lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_get_width_texture_1d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_1d_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_get_width_texture_1d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_1d_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_get_width_texture_1d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_1d_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width(uint lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_get_width_texture_1d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_1d_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width(uint lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_get_width_texture_1d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_1d_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct texture1d : _texture1d<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture1d'");

  texture1d() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  texture1d() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  texture1d() ray_data = delete;
#endif

  METAL_FUNC texture1d(const thread texture1d &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d(const device texture1d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d(const constant texture1d &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const ray_data texture1d &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture1d(const object_data texture1d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d(const thread texture1d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d(const device texture1d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d(const constant texture1d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const ray_data texture1d &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture1d(const object_data texture1d &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const thread texture1d &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const device texture1d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const constant texture1d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const ray_data texture1d &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const object_data texture1d &) ray_data = default;
#endif
#endif

  thread texture1d &operator=(const thread texture1d &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture1d &operator=(const device texture1d &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture1d &operator=(const constant texture1d &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread texture1d &operator=(const ray_data texture1d &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread texture1d &operator=(const object_data texture1d &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture1d &operator=(const thread texture1d &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture1d &operator=(const device texture1d &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture1d &operator=(const constant texture1d &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device texture1d &operator=(const ray_data texture1d &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device texture1d &operator=(const object_data texture1d &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture1d &operator=(const thread texture1d &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture1d &operator=(const device texture1d &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture1d &operator=(const constant texture1d &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture1d &operator=(const ray_data texture1d &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture1d &operator=(const object_data texture1d &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture1d &operator=(const thread texture1d &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture1d &operator=(const device texture1d &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture1d &operator=(const constant texture1d &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data texture1d &operator=(const ray_data texture1d &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture1d &operator=(const object_data texture1d &) object_data = delete;
#endif

private:
  __metal_texture_1d_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture1d<T, a>);
#endif
  friend struct _texture1d_sample<T, a>;
  friend struct _texture1d_read<T, a>;
  friend struct _texture1d_write<T, a>;
#if defined(__HAVE_TEXTURE_RELAXED_ORDER_ATOMIC__)
  friend struct _texture1d_atomic_load<T, a>;
  friend struct _texture1d_atomic_store<T, a>;
  friend struct _texture1d_atomic_compare_exchange<T, a>;
  friend struct _texture1d_atomic_exchange<T, a>;
  friend struct _texture1d_atomic_fetch_and<T, a>;
  friend struct _texture1d_atomic_fetch_and_arith<T, a>;
  friend struct _texture1d_atomic_modify<T, a>;
#endif
  friend struct _texture1d<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct texture1d<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _texture1d<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture1d'");

  METAL_FUNC texture1d() thread : t(__metal_get_null_texture_1d_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d() constant : t(__metal_get_null_texture_1d_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d() ray_data : t(__metal_get_null_texture_1d_t()) {}
#endif

  METAL_FUNC texture1d(const thread texture1d &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d(const device texture1d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d(const constant texture1d &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const ray_data texture1d &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture1d(const object_data texture1d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d(const thread texture1d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d(const device texture1d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d(const constant texture1d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const ray_data texture1d &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture1d(const object_data texture1d &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const thread texture1d &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const device texture1d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const constant texture1d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const ray_data texture1d &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const object_data texture1d &) ray_data = default;
#endif
#endif

  METAL_FUNC thread texture1d &operator=(const thread texture1d &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture1d &operator=(const device texture1d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture1d &operator=(const constant texture1d &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread texture1d &operator=(const ray_data texture1d &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread texture1d &operator=(const object_data texture1d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture1d &operator=(const thread texture1d &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture1d &operator=(const device texture1d &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture1d &operator=(const constant texture1d &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device texture1d &operator=(const ray_data texture1d &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device texture1d &operator=(const object_data texture1d &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture1d &operator=(const thread texture1d &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture1d &operator=(const device texture1d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture1d &operator=(const constant texture1d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture1d &operator=(const ray_data texture1d &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture1d &operator=(const object_data texture1d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture1d &operator=(const thread texture1d &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture1d &operator=(const device texture1d &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture1d &operator=(const constant texture1d &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture1d &operator=(const ray_data texture1d &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture1d &operator=(const object_data texture1d &) object_data = default;
#endif

private:
  __metal_texture_1d_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture1d<T, a>);
#endif
  friend struct _texture1d_sample<T, a>;
  friend struct _texture1d_read<T, a>;
  friend struct _texture1d_write<T, a>;
#if defined(__HAVE_TEXTURE_RELAXED_ORDER_ATOMIC__)
  friend struct _texture1d_atomic_load<T, a>;
  friend struct _texture1d_atomic_store<T, a>;
  friend struct _texture1d_atomic_compare_exchange<T, a>;
  friend struct _texture1d_atomic_exchange<T, a>;
  friend struct _texture1d_atomic_fetch_and<T, a>;
  friend struct _texture1d_atomic_fetch_and_arith<T, a>;
  friend struct _texture1d_atomic_modify<T, a>;
#endif
  friend struct _texture1d<T, a>;
};
#endif

template <typename T, access a, typename _Enable = void>
struct _texture1d_array_sample
{
};

#if defined(__HAVE_TEXTURE_ULONG_COLOR_CHANNEL__)
template <access a>
struct _texture1d_array_sample<ulong, a, typename enable_if<_is_valid_sample(a)>::type>
{
};
#endif

template <typename T, access a>
struct _texture1d_array_sample<T, a, typename enable_if<_is_valid_sample(a)>::type>
{
  METAL_FUNC vec<T, 4> sample(sampler s, float coord, uint array) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_sample_texture_1d_array_t(derived.t, s.val, coord, array, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float coord, uint array) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_1d_array_t(derived.t, s.val, coord, array, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float coord, uint array) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_sample_texture_1d_array_t(derived.t, s.val, coord, array, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float coord, uint array) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_1d_array_t(derived.t, s.val, coord, array, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float coord, uint array) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_sample_texture_1d_array_t(derived.t, s.val, coord, array, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float coord, uint array) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_1d_array_t(derived.t, s.val, coord, array, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> sample(sampler s, float coord, uint array) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_sample_texture_1d_array_t(derived.t, s.val, coord, array, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float coord, uint array) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_1d_array_t(derived.t, s.val, coord, array, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> sample(sampler s, float coord, uint array) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_sample_texture_1d_array_t(derived.t, s.val, coord, array, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float coord, uint array) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_1d_array_t(derived.t, s.val, coord, array, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture1d_array_read
{
};

template <typename T, access a>
struct _texture1d_array_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord, ushort array, ushort lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort coord, ushort array, ushort lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint coord, uint array, uint lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint coord, uint array, uint lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord, ushort array, ushort lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort coord, ushort array, ushort lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint coord, uint array, uint lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint coord, uint array, uint lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord, ushort array, ushort lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort coord, ushort array, ushort lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint coord, uint array, uint lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint coord, uint array, uint lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord, ushort array, ushort lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort coord, ushort array, ushort lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint coord, uint array, uint lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint coord, uint array, uint lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord, ushort array, ushort lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort coord, ushort array, ushort lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint coord, uint array, uint lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint coord, uint array, uint lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture1d_array_write
{
};

template <typename T, access a>
struct _texture1d_array_write<T, a, typename enable_if<_is_valid_write(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord, ushort array, ushort lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    __metal_write_texture_1d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort coord, ushort array, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord, uint array, uint lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    __metal_write_texture_1d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint coord, uint array, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord, ushort array, ushort lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    __metal_write_texture_1d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort coord, ushort array, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord, uint array, uint lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    __metal_write_texture_1d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint coord, uint array, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord, ushort array, ushort lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    __metal_write_texture_1d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort coord, ushort array, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord, uint array, uint lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    __metal_write_texture_1d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint coord, uint array, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord, ushort array, ushort lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    __metal_write_texture_1d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort coord, ushort array, ushort lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord, uint array, uint lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    __metal_write_texture_1d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint coord, uint array, uint lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord, ushort array, ushort lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    __metal_write_texture_1d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort coord, ushort array, ushort lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord, uint array, uint lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    __metal_write_texture_1d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint coord, uint array, uint lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
};

#if defined(__HAVE_TEXTURE_RELAXED_ORDER_ATOMIC__)
template <typename T, access a, typename _Enable = void>
struct _texture1d_array_atomic_load
{
};

template <typename T, access a>
struct _texture1d_array_atomic_load<T, a, typename enable_if<_is_valid_read(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC vec<T, 4> atomic_load(ushort coord, ushort array) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_1d_array_t(derived.t, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint coord, uint array) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_1d_array_t(derived.t, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(ushort coord, ushort array) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_1d_array_t(derived.t, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint coord, uint array) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_1d_array_t(derived.t, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(ushort coord, ushort array) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_1d_array_t(derived.t, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint coord, uint array) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_1d_array_t(derived.t, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(ushort coord, ushort array) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_1d_array_t(derived.t, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint coord, uint array) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_1d_array_t(derived.t, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(ushort coord, ushort array) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_1d_array_t(derived.t, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint coord, uint array) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_1d_array_t(derived.t, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture1d_array_atomic_store
{
};

template <typename T, access a>
struct _texture1d_array_atomic_store<T, a, typename enable_if<_is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort coord, ushort array) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_1d_array_t(derived.t, color, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint coord, uint array) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_1d_array_t(derived.t, color, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort coord, ushort array) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_1d_array_t(derived.t, color, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint coord, uint array) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_1d_array_t(derived.t, color, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort coord, ushort array) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_1d_array_t(derived.t, color, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint coord, uint array) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_1d_array_t(derived.t, color, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort coord, ushort array) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_1d_array_t(derived.t, color, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint coord, uint array) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_1d_array_t(derived.t, color, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort coord, ushort array) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_1d_array_t(derived.t, color, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint coord, uint array) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_1d_array_t(derived.t, color, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture1d_array_atomic_compare_exchange
{
};

template <typename T, access a>
struct _texture1d_array_atomic_compare_exchange<T, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC bool atomic_compare_exchange_weak(ushort coord, ushort array, thread vec<T, 4> *expected, vec<T, 4> desired) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_1d_array_t(derived.t, coord, array, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint coord, uint array, thread vec<T, 4> *expected, vec<T, 4> desired) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_1d_array_t(derived.t, coord, array, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(ushort coord, ushort array, thread vec<T, 4> *expected, vec<T, 4> desired) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_1d_array_t(derived.t, coord, array, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint coord, uint array, thread vec<T, 4> *expected, vec<T, 4> desired) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_1d_array_t(derived.t, coord, array, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(ushort coord, ushort array, thread vec<T, 4> *expected, vec<T, 4> desired) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_1d_array_t(derived.t, coord, array, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint coord, uint array, thread vec<T, 4> *expected, vec<T, 4> desired) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_1d_array_t(derived.t, coord, array, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(ushort coord, ushort array, thread vec<T, 4> *expected, vec<T, 4> desired) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_1d_array_t(derived.t, coord, array, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint coord, uint array, thread vec<T, 4> *expected, vec<T, 4> desired) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_1d_array_t(derived.t, coord, array, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(ushort coord, ushort array, thread vec<T, 4> *expected, vec<T, 4> desired) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_1d_array_t(derived.t, coord, array, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint coord, uint array, thread vec<T, 4> *expected, vec<T, 4> desired) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_1d_array_t(derived.t, coord, array, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture1d_array_atomic_exchange
{
};

template <typename T, access a>
struct _texture1d_array_atomic_exchange<T, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC vec<T, 4> atomic_exchange(ushort coord, ushort array, vec<T, 4> desired) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_1d_array_t(derived.t, coord, array, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint coord, uint array, vec<T, 4> desired) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_1d_array_t(derived.t, coord, array, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(ushort coord, ushort array, vec<T, 4> desired) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_1d_array_t(derived.t, coord, array, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint coord, uint array, vec<T, 4> desired) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_1d_array_t(derived.t, coord, array, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(ushort coord, ushort array, vec<T, 4> desired) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_1d_array_t(derived.t, coord, array, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint coord, uint array, vec<T, 4> desired) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_1d_array_t(derived.t, coord, array, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(ushort coord, ushort array, vec<T, 4> desired) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_1d_array_t(derived.t, coord, array, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint coord, uint array, vec<T, 4> desired) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_1d_array_t(derived.t, coord, array, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(ushort coord, ushort array, vec<T, 4> desired) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_1d_array_t(derived.t, coord, array, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint coord, uint array, vec<T, 4> desired) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_1d_array_t(derived.t, coord, array, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture1d_array_atomic_fetch_and
{
};

template <typename T, access a>
struct _texture1d_array_atomic_fetch_and<T, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort coord, ushort array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort coord, ushort array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort coord, ushort array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort coord, ushort array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort coord, ushort array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint coord, uint array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint coord, uint array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint coord, uint array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint coord, uint array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint coord, uint array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort coord, ushort array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort coord, ushort array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort coord, ushort array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort coord, ushort array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort coord, ushort array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint coord, uint array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint coord, uint array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint coord, uint array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint coord, uint array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint coord, uint array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort coord, ushort array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort coord, ushort array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort coord, ushort array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort coord, ushort array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort coord, ushort array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint coord, uint array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint coord, uint array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint coord, uint array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint coord, uint array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint coord, uint array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort coord, ushort array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort coord, ushort array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort coord, ushort array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort coord, ushort array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort coord, ushort array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint coord, uint array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint coord, uint array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint coord, uint array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint coord, uint array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint coord, uint array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort coord, ushort array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort coord, ushort array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort coord, ushort array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort coord, ushort array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort coord, ushort array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint coord, uint array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint coord, uint array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint coord, uint array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint coord, uint array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint coord, uint array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture1d_array_atomic_fetch_and_arith
{
};

template <typename T, access a>
struct _texture1d_array_atomic_fetch_and_arith<T, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort coord, ushort array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort coord, ushort array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint coord, uint array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint coord, uint array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort coord, ushort array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort coord, ushort array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint coord, uint array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint coord, uint array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort coord, ushort array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort coord, ushort array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint coord, uint array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint coord, uint array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort coord, ushort array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort coord, ushort array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint coord, uint array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint coord, uint array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort coord, ushort array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort coord, ushort array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint coord, uint array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint coord, uint array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture1d_array_atomic_modify
{
};

template <access a>
struct _texture1d_array_atomic_modify<ulong, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a)>::type>
{
  METAL_FUNC void atomic_max(ushort coord, ushort array, ulong4 operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort coord, ushort array, ulong4 operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint coord, uint array, ulong4 operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint coord, uint array, ulong4 operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(ushort coord, ushort array, ulong4 operand) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort coord, ushort array, ulong4 operand) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint coord, uint array, ulong4 operand) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint coord, uint array, ulong4 operand) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(ushort coord, ushort array, ulong4 operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort coord, ushort array, ulong4 operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint coord, uint array, ulong4 operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint coord, uint array, ulong4 operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(ushort coord, ushort array, ulong4 operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort coord, ushort array, ulong4 operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint coord, uint array, ulong4 operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint coord, uint array, ulong4 operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(ushort coord, ushort array, ulong4 operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort coord, ushort array, ulong4 operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint coord, uint array, ulong4 operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint coord, uint array, ulong4 operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_1d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};
#endif

template <typename T, access a, typename _Enable = void>
struct _texture1d_array
{
};

template <typename T, access a>
struct _texture1d_array<T, a, typename enable_if<is_color_texture_channel<T>::value>::type>
  : _deleted_operators<texture1d_array<T, a>>
  , _texture1d_array_sample<T, a>
  , _texture1d_array_read<T, a>
  , _texture1d_array_write<T, a>
#if defined(__HAVE_TEXTURE_RELAXED_ORDER_ATOMIC__)
  , _texture1d_array_atomic_load<T, a>
  , _texture1d_array_atomic_store<T, a>
  , _texture1d_array_atomic_compare_exchange<T, a>
  , _texture1d_array_atomic_exchange<T, a>
  , _texture1d_array_atomic_fetch_and<T, a>
  , _texture1d_array_atomic_fetch_and_arith<T, a>
  , _texture1d_array_atomic_modify<T, a>
#endif
{
#if defined(__HAVE_TEXTURE_READWRITE__)
  METAL_FUNC void fence() thread
  {
    thread auto &derived = static_cast<thread texture1d_array<T, a> &>(*this);
    __metal_fence_texture_1d_array_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() device
  {
    device auto &derived = static_cast<device texture1d_array<T, a> &>(*this);
    __metal_fence_texture_1d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() constant
  {
    constant auto &derived = static_cast<constant texture1d_array<T, a> &>(*this);
    __metal_fence_texture_1d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC void fence() ray_data
  {
    ray_data auto &derived = static_cast<ray_data texture1d_array<T, a> &>(*this);
    __metal_fence_texture_1d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC void fence() object_data
  {
    object_data auto &derived = static_cast<object_data texture1d_array<T, a> &>(*this);
    __metal_fence_texture_1d_array_t(derived.t);
  }
#endif
#endif

  METAL_FUNC uint get_width(uint lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_get_width_texture_1d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_get_array_size_texture_1d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_1d_array_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_get_width_texture_1d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_get_array_size_texture_1d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_1d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_get_width_texture_1d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_get_array_size_texture_1d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_1d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width(uint lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_get_width_texture_1d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_get_array_size_texture_1d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_1d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width(uint lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_get_width_texture_1d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_get_array_size_texture_1d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_1d_array_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct texture1d_array : _texture1d_array<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture1d_array'");

  texture1d_array() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  texture1d_array() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  texture1d_array() ray_data = delete;
#endif

  METAL_FUNC texture1d_array(const thread texture1d_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d_array(const device texture1d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d_array(const constant texture1d_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const ray_data texture1d_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture1d_array(const object_data texture1d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d_array(const thread texture1d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d_array(const device texture1d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d_array(const constant texture1d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const ray_data texture1d_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture1d_array(const object_data texture1d_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const thread texture1d_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const device texture1d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const constant texture1d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const ray_data texture1d_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const object_data texture1d_array &) ray_data = default;
#endif
#endif

  thread texture1d_array &operator=(const thread texture1d_array &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture1d_array &operator=(const device texture1d_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture1d_array &operator=(const constant texture1d_array &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread texture1d_array &operator=(const ray_data texture1d_array &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread texture1d_array &operator=(const object_data texture1d_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture1d_array &operator=(const thread texture1d_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture1d_array &operator=(const device texture1d_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture1d_array &operator=(const constant texture1d_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device texture1d_array &operator=(const ray_data texture1d_array &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device texture1d_array &operator=(const object_data texture1d_array &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture1d_array &operator=(const thread texture1d_array &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture1d_array &operator=(const device texture1d_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture1d_array &operator=(const constant texture1d_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture1d_array &operator=(const ray_data texture1d_array &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture1d_array &operator=(const object_data texture1d_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture1d_array &operator=(const thread texture1d_array &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture1d_array &operator=(const device texture1d_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture1d_array &operator=(const constant texture1d_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data texture1d_array &operator=(const ray_data texture1d_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture1d_array &operator=(const object_data texture1d_array &) object_data = delete;
#endif

private:
  __metal_texture_1d_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture1d_array<T, a>);
#endif
  friend struct _texture1d_array_sample<T, a>;
  friend struct _texture1d_array_read<T, a>;
  friend struct _texture1d_array_write<T, a>;
#if defined(__HAVE_TEXTURE_RELAXED_ORDER_ATOMIC__)
  friend struct _texture1d_array_atomic_load<T, a>;
  friend struct _texture1d_array_atomic_store<T, a>;
  friend struct _texture1d_array_atomic_compare_exchange<T, a>;
  friend struct _texture1d_array_atomic_exchange<T, a>;
  friend struct _texture1d_array_atomic_fetch_and<T, a>;
  friend struct _texture1d_array_atomic_fetch_and_arith<T, a>;
  friend struct _texture1d_array_atomic_modify<T, a>;
#endif
  friend struct _texture1d_array<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct texture1d_array<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _texture1d_array<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture1d_array'");

  METAL_FUNC texture1d_array() thread : t(__metal_get_null_texture_1d_array_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d_array() constant : t(__metal_get_null_texture_1d_array_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array() ray_data : t(__metal_get_null_texture_1d_array_t()) {}
#endif

  METAL_FUNC texture1d_array(const thread texture1d_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d_array(const device texture1d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d_array(const constant texture1d_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const ray_data texture1d_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture1d_array(const object_data texture1d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d_array(const thread texture1d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d_array(const device texture1d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d_array(const constant texture1d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const ray_data texture1d_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture1d_array(const object_data texture1d_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const thread texture1d_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const device texture1d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const constant texture1d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const ray_data texture1d_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const object_data texture1d_array &) ray_data = default;
#endif
#endif

  METAL_FUNC thread texture1d_array &operator=(const thread texture1d_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture1d_array &operator=(const device texture1d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture1d_array &operator=(const constant texture1d_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread texture1d_array &operator=(const ray_data texture1d_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread texture1d_array &operator=(const object_data texture1d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture1d_array &operator=(const thread texture1d_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture1d_array &operator=(const device texture1d_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture1d_array &operator=(const constant texture1d_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device texture1d_array &operator=(const ray_data texture1d_array &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device texture1d_array &operator=(const object_data texture1d_array &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture1d_array &operator=(const thread texture1d_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture1d_array &operator=(const device texture1d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture1d_array &operator=(const constant texture1d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture1d_array &operator=(const ray_data texture1d_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture1d_array &operator=(const object_data texture1d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture1d_array &operator=(const thread texture1d_array &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture1d_array &operator=(const device texture1d_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture1d_array &operator=(const constant texture1d_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture1d_array &operator=(const ray_data texture1d_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture1d_array &operator=(const object_data texture1d_array &) object_data = default;
#endif

private:
  __metal_texture_1d_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture1d_array<T, a>);
#endif
  friend struct _texture1d_array_sample<T, a>;
  friend struct _texture1d_array_read<T, a>;
  friend struct _texture1d_array_write<T, a>;
#if defined(__HAVE_TEXTURE_RELAXED_ORDER_ATOMIC__)
  friend struct _texture1d_array_atomic_load<T, a>;
  friend struct _texture1d_array_atomic_store<T, a>;
  friend struct _texture1d_array_atomic_compare_exchange<T, a>;
  friend struct _texture1d_array_atomic_exchange<T, a>;
  friend struct _texture1d_array_atomic_fetch_and<T, a>;
  friend struct _texture1d_array_atomic_fetch_and_arith<T, a>;
  friend struct _texture1d_array_atomic_modify<T, a>;
#endif
  friend struct _texture1d_array<T, a>;
};
#endif

template <typename T, access a, typename _Enable = void>
struct _texture2d_sample
{
};

#if defined(__HAVE_TEXTURE_ULONG_COLOR_CHANNEL__)
template <access a>
struct _texture2d_sample<ulong, a, typename enable_if<_is_valid_sample(a)>::type>
{
};
#endif

template <typename T, access a>
struct _texture2d_sample<T, a, typename enable_if<_is_valid_sample(a)>::type>
{
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, gradient2d options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_2d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_2d_t(derived.t, s.val, coord, int(a));
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, gradient2d options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_2d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_2d_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, gradient2d options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_2d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_2d_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, gradient2d options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_2d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_2d_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, gradient2d options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_2d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_2d_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_read
{
};

template <typename T, access a>
struct _texture2d_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_read_texture_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_read_texture_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort lod = 0) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_read_texture_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_read_texture_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_read_texture_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_read_texture_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_read_texture_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_read_texture_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_read_texture_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_read_texture_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_write
{
};

template <typename T, access a>
struct _texture2d_write<T, a, typename enable_if<_is_valid_write(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    __metal_write_texture_2d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    __metal_write_texture_2d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    __metal_write_texture_2d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    __metal_write_texture_2d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    __metal_write_texture_2d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    __metal_write_texture_2d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    __metal_write_texture_2d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    __metal_write_texture_2d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    __metal_write_texture_2d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    __metal_write_texture_2d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_gather
{
};

template <typename T, access a>
struct _texture2d_gather<T, a, typename enable_if<_is_valid_gather(a)>::type>
{
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, int2 offset = int2(0), component c = component::x) const thread METAL_CONST_ARG(c)
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_gather_texture_2d_t(derived.t, s.val, coord, true, offset, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, int2 offset = int2(0), component c = component::x) const thread METAL_CONST_ARG(c)
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_2d_t(derived.t, s.val, coord, true, offset, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, int2 offset = int2(0), component c = component::x) const device METAL_CONST_ARG(c)
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_gather_texture_2d_t(derived.t, s.val, coord, true, offset, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, int2 offset = int2(0), component c = component::x) const device METAL_CONST_ARG(c)
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_2d_t(derived.t, s.val, coord, true, offset, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, int2 offset = int2(0), component c = component::x) const constant METAL_CONST_ARG(c)
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_gather_texture_2d_t(derived.t, s.val, coord, true, offset, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, int2 offset = int2(0), component c = component::x) const constant METAL_CONST_ARG(c)
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_2d_t(derived.t, s.val, coord, true, offset, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, int2 offset = int2(0), component c = component::x) const ray_data METAL_CONST_ARG(c)
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_gather_texture_2d_t(derived.t, s.val, coord, true, offset, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, int2 offset = int2(0), component c = component::x) const ray_data METAL_CONST_ARG(c)
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_2d_t(derived.t, s.val, coord, true, offset, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, int2 offset = int2(0), component c = component::x) const object_data METAL_CONST_ARG(c)
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_gather_texture_2d_t(derived.t, s.val, coord, true, offset, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, int2 offset = int2(0), component c = component::x) const object_data METAL_CONST_ARG(c)
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_2d_t(derived.t, s.val, coord, true, offset, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};

#if defined(__HAVE_TEXTURE_RELAXED_ORDER_ATOMIC__)
template <typename T, access a, typename _Enable = void>
struct _texture2d_atomic_load
{
};

template <typename T, access a>
struct _texture2d_atomic_load<T, a, typename enable_if<_is_valid_read(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC vec<T, 4> atomic_load(ushort2 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_2d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint2 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_2d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(ushort2 coord) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_2d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint2 coord) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_2d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(ushort2 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_2d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint2 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_2d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(ushort2 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_2d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint2 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_2d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(ushort2 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_2d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint2 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_2d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_atomic_store
{
};

template <typename T, access a>
struct _texture2d_atomic_store<T, a, typename enable_if<_is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort2 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_2d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint2 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_2d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort2 coord) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_2d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint2 coord) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_2d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort2 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_2d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint2 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_2d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort2 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_2d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint2 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_2d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort2 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_2d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint2 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_2d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_atomic_compare_exchange
{
};

template <typename T, access a>
struct _texture2d_atomic_compare_exchange<T, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC bool atomic_compare_exchange_weak(ushort2 coord, thread vec<T, 4> *expected, vec<T, 4> desired) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_2d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint2 coord, thread vec<T, 4> *expected, vec<T, 4> desired) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_2d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(ushort2 coord, thread vec<T, 4> *expected, vec<T, 4> desired) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_2d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint2 coord, thread vec<T, 4> *expected, vec<T, 4> desired) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_2d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(ushort2 coord, thread vec<T, 4> *expected, vec<T, 4> desired) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_2d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint2 coord, thread vec<T, 4> *expected, vec<T, 4> desired) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_2d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(ushort2 coord, thread vec<T, 4> *expected, vec<T, 4> desired) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_2d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint2 coord, thread vec<T, 4> *expected, vec<T, 4> desired) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_2d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(ushort2 coord, thread vec<T, 4> *expected, vec<T, 4> desired) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_2d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint2 coord, thread vec<T, 4> *expected, vec<T, 4> desired) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_2d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_atomic_exchange
{
};

template <typename T, access a>
struct _texture2d_atomic_exchange<T, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC vec<T, 4> atomic_exchange(ushort2 coord, vec<T, 4> desired) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_2d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint2 coord, vec<T, 4> desired) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_2d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(ushort2 coord, vec<T, 4> desired) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_2d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint2 coord, vec<T, 4> desired) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_2d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(ushort2 coord, vec<T, 4> desired) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_2d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint2 coord, vec<T, 4> desired) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_2d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(ushort2 coord, vec<T, 4> desired) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_2d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint2 coord, vec<T, 4> desired) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_2d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(ushort2 coord, vec<T, 4> desired) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_2d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint2 coord, vec<T, 4> desired) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_2d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_atomic_fetch_and
{
};

template <typename T, access a>
struct _texture2d_atomic_fetch_and<T, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort2 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort2 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort2 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort2 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort2 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint2 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint2 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint2 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint2 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint2 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort2 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort2 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort2 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort2 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort2 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint2 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint2 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint2 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint2 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint2 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort2 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort2 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort2 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort2 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort2 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint2 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint2 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint2 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint2 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint2 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort2 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort2 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort2 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort2 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort2 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint2 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint2 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint2 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint2 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint2 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort2 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort2 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort2 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort2 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort2 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint2 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint2 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint2 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint2 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint2 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_atomic_fetch_and_arith
{
};

template <typename T, access a>
struct _texture2d_atomic_fetch_and_arith<T, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort2 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort2 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint2 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint2 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort2 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort2 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint2 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint2 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort2 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort2 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint2 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint2 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort2 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort2 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint2 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint2 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort2 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort2 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint2 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint2 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_atomic_modify
{
};

template <access a>
struct _texture2d_atomic_modify<ulong, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a)>::type>
{
  METAL_FUNC void atomic_max(ushort2 coord, ulong4 operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort2 coord, ulong4 operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint2 coord, ulong4 operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint2 coord, ulong4 operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(ushort2 coord, ulong4 operand) const device
  {
    const device auto &derived = static_cast<const device texture2d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort2 coord, ulong4 operand) const device
  {
    const device auto &derived = static_cast<const device texture2d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint2 coord, ulong4 operand) const device
  {
    const device auto &derived = static_cast<const device texture2d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint2 coord, ulong4 operand) const device
  {
    const device auto &derived = static_cast<const device texture2d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(ushort2 coord, ulong4 operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort2 coord, ulong4 operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint2 coord, ulong4 operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint2 coord, ulong4 operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(ushort2 coord, ulong4 operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort2 coord, ulong4 operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint2 coord, ulong4 operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint2 coord, ulong4 operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(ushort2 coord, ulong4 operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort2 coord, ulong4 operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint2 coord, ulong4 operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint2 coord, ulong4 operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_2d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};
#endif

template <typename T, access a, typename _Enable = void>
struct _texture2d
{
};

template <typename T, access a>
struct _texture2d<T, a, typename enable_if<is_color_texture_channel<T>::value>::type>
  : _deleted_operators<texture2d<T, a>>
  , _texture2d_sample<T, a>
  , _texture2d_read<T, a>
  , _texture2d_write<T, a>
  , _texture2d_gather<T, a>
#if defined(__HAVE_TEXTURE_RELAXED_ORDER_ATOMIC__)
  , _texture2d_atomic_load<T, a>
  , _texture2d_atomic_store<T, a>
  , _texture2d_atomic_compare_exchange<T, a>
  , _texture2d_atomic_exchange<T, a>
  , _texture2d_atomic_fetch_and<T, a>
  , _texture2d_atomic_fetch_and_arith<T, a>
  , _texture2d_atomic_modify<T, a>
#endif
{
#if defined(__HAVE_TEXTURE_READWRITE__)
  METAL_FUNC void fence() thread
  {
    thread auto &derived = static_cast<thread texture2d<T, a> &>(*this);
    __metal_fence_texture_2d_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() device
  {
    device auto &derived = static_cast<device texture2d<T, a> &>(*this);
    __metal_fence_texture_2d_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() constant
  {
    constant auto &derived = static_cast<constant texture2d<T, a> &>(*this);
    __metal_fence_texture_2d_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC void fence() ray_data
  {
    ray_data auto &derived = static_cast<ray_data texture2d<T, a> &>(*this);
    __metal_fence_texture_2d_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC void fence() object_data
  {
    object_data auto &derived = static_cast<object_data texture2d<T, a> &>(*this);
    __metal_fence_texture_2d_t(derived.t);
  }
#endif
#endif

  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_get_width_texture_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_get_height_texture_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_2d_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_get_width_texture_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_get_height_texture_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_2d_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_get_width_texture_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_get_height_texture_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_2d_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_get_width_texture_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_get_height_texture_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_2d_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_get_width_texture_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_get_height_texture_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_2d_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct texture2d : _texture2d<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture2d'");

  texture2d() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  texture2d() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  texture2d() ray_data = delete;
#endif

  METAL_FUNC texture2d(const thread texture2d &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d(const device texture2d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d(const constant texture2d &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const ray_data texture2d &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d(const object_data texture2d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d(const thread texture2d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d(const device texture2d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d(const constant texture2d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const ray_data texture2d &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d(const object_data texture2d &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const thread texture2d &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const device texture2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const constant texture2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const ray_data texture2d &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const object_data texture2d &) ray_data = default;
#endif
#endif

  thread texture2d &operator=(const thread texture2d &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture2d &operator=(const device texture2d &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture2d &operator=(const constant texture2d &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread texture2d &operator=(const ray_data texture2d &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread texture2d &operator=(const object_data texture2d &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture2d &operator=(const thread texture2d &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture2d &operator=(const device texture2d &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture2d &operator=(const constant texture2d &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device texture2d &operator=(const ray_data texture2d &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device texture2d &operator=(const object_data texture2d &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d &operator=(const thread texture2d &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d &operator=(const device texture2d &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d &operator=(const constant texture2d &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d &operator=(const ray_data texture2d &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d &operator=(const object_data texture2d &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture2d &operator=(const thread texture2d &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture2d &operator=(const device texture2d &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture2d &operator=(const constant texture2d &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data texture2d &operator=(const ray_data texture2d &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture2d &operator=(const object_data texture2d &) object_data = delete;
#endif

private:
  __metal_texture_2d_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture2d<T, a>);
#endif
  friend struct _texture2d_sample<T, a>;
  friend struct _texture2d_read<T, a>;
  friend struct _texture2d_write<T, a>;
  friend struct _texture2d_gather<T, a>;
#if defined(__HAVE_TEXTURE_RELAXED_ORDER_ATOMIC__)
  friend struct _texture2d_atomic_load<T, a>;
  friend struct _texture2d_atomic_store<T, a>;
  friend struct _texture2d_atomic_compare_exchange<T, a>;
  friend struct _texture2d_atomic_exchange<T, a>;
  friend struct _texture2d_atomic_fetch_and<T, a>;
  friend struct _texture2d_atomic_fetch_and_arith<T, a>;
  friend struct _texture2d_atomic_modify<T, a>;
#endif
  friend struct _texture2d<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct texture2d<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _texture2d<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture2d'");

  METAL_FUNC texture2d() thread : t(__metal_get_null_texture_2d_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d() constant : t(__metal_get_null_texture_2d_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d() ray_data : t(__metal_get_null_texture_2d_t()) {}
#endif

  METAL_FUNC texture2d(const thread texture2d &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d(const device texture2d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d(const constant texture2d &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const ray_data texture2d &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d(const object_data texture2d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d(const thread texture2d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d(const device texture2d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d(const constant texture2d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const ray_data texture2d &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d(const object_data texture2d &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const thread texture2d &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const device texture2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const constant texture2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const ray_data texture2d &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const object_data texture2d &) ray_data = default;
#endif
#endif

  METAL_FUNC thread texture2d &operator=(const thread texture2d &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture2d &operator=(const device texture2d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture2d &operator=(const constant texture2d &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread texture2d &operator=(const ray_data texture2d &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread texture2d &operator=(const object_data texture2d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture2d &operator=(const thread texture2d &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture2d &operator=(const device texture2d &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture2d &operator=(const constant texture2d &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device texture2d &operator=(const ray_data texture2d &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device texture2d &operator=(const object_data texture2d &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d &operator=(const thread texture2d &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d &operator=(const device texture2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d &operator=(const constant texture2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d &operator=(const ray_data texture2d &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d &operator=(const object_data texture2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d &operator=(const thread texture2d &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d &operator=(const device texture2d &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d &operator=(const constant texture2d &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d &operator=(const ray_data texture2d &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d &operator=(const object_data texture2d &) object_data = default;
#endif

private:
  __metal_texture_2d_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture2d<T, a>);
#endif
  friend struct _texture2d_sample<T, a>;
  friend struct _texture2d_read<T, a>;
  friend struct _texture2d_write<T, a>;
  friend struct _texture2d_gather<T, a>;
#if defined(__HAVE_TEXTURE_RELAXED_ORDER_ATOMIC__)
  friend struct _texture2d_atomic_load<T, a>;
  friend struct _texture2d_atomic_store<T, a>;
  friend struct _texture2d_atomic_compare_exchange<T, a>;
  friend struct _texture2d_atomic_exchange<T, a>;
  friend struct _texture2d_atomic_fetch_and<T, a>;
  friend struct _texture2d_atomic_fetch_and_arith<T, a>;
  friend struct _texture2d_atomic_modify<T, a>;
#endif
  friend struct _texture2d<T, a>;
};
#endif

template <typename T, access a, typename _Enable = void>
struct _texture2d_array_sample
{
};

#if defined(__HAVE_TEXTURE_ULONG_COLOR_CHANNEL__)
template <access a>
struct _texture2d_array_sample<ulong, a, typename enable_if<_is_valid_sample(a)>::type>
{
};
#endif

template <typename T, access a>
struct _texture2d_array_sample<T, a, typename enable_if<_is_valid_sample(a)>::type>
{
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_2d_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_2d_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_2d_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_2d_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_2d_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_2d_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_2d_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_2d_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_2d_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_2d_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_array_read
{
};

template <typename T, access a>
struct _texture2d_array_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort array, ushort lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort array, ushort lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint array, uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint array, uint lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort array, ushort lod = 0) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort array, ushort lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint array, uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint array, uint lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort array, ushort lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort array, ushort lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint array, uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint array, uint lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort array, ushort lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort array, ushort lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint array, uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint array, uint lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort array, ushort lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort array, ushort lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint array, uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint array, uint lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_array_write
{
};

template <typename T, access a>
struct _texture2d_array_write<T, a, typename enable_if<_is_valid_write(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort array, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    __metal_write_texture_2d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort array, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint array, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    __metal_write_texture_2d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint array, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort array, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    __metal_write_texture_2d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort array, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint array, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    __metal_write_texture_2d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint array, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort array, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    __metal_write_texture_2d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort array, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint array, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    __metal_write_texture_2d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint array, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort array, ushort lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    __metal_write_texture_2d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort array, ushort lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint array, uint lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    __metal_write_texture_2d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint array, uint lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort array, ushort lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    __metal_write_texture_2d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort array, ushort lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint array, uint lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    __metal_write_texture_2d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint array, uint lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_array_gather
{
};

template <typename T, access a>
struct _texture2d_array_gather<T, a, typename enable_if<_is_valid_gather(a)>::type>
{
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, uint array, int2 offset = int2(0), component c = component::x) const thread METAL_CONST_ARG(c)
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_gather_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, uint array, int2 offset = int2(0), component c = component::x) const thread METAL_CONST_ARG(c)
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, uint array, int2 offset = int2(0), component c = component::x) const device METAL_CONST_ARG(c)
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_gather_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, uint array, int2 offset = int2(0), component c = component::x) const device METAL_CONST_ARG(c)
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, uint array, int2 offset = int2(0), component c = component::x) const constant METAL_CONST_ARG(c)
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_gather_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, uint array, int2 offset = int2(0), component c = component::x) const constant METAL_CONST_ARG(c)
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, uint array, int2 offset = int2(0), component c = component::x) const ray_data METAL_CONST_ARG(c)
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_gather_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, uint array, int2 offset = int2(0), component c = component::x) const ray_data METAL_CONST_ARG(c)
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, uint array, int2 offset = int2(0), component c = component::x) const object_data METAL_CONST_ARG(c)
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_gather_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, uint array, int2 offset = int2(0), component c = component::x) const object_data METAL_CONST_ARG(c)
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};

#if defined(__HAVE_TEXTURE_RELAXED_ORDER_ATOMIC__)
template <typename T, access a, typename _Enable = void>
struct _texture2d_array_atomic_load
{
};

template <typename T, access a>
struct _texture2d_array_atomic_load<T, a, typename enable_if<_is_valid_read(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC vec<T, 4> atomic_load(ushort2 coord, ushort array) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_2d_array_t(derived.t, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint2 coord, uint array) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_2d_array_t(derived.t, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(ushort2 coord, ushort array) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_2d_array_t(derived.t, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint2 coord, uint array) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_2d_array_t(derived.t, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(ushort2 coord, ushort array) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_2d_array_t(derived.t, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint2 coord, uint array) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_2d_array_t(derived.t, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(ushort2 coord, ushort array) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_2d_array_t(derived.t, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint2 coord, uint array) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_2d_array_t(derived.t, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(ushort2 coord, ushort array) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_2d_array_t(derived.t, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint2 coord, uint array) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_2d_array_t(derived.t, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_array_atomic_store
{
};

template <typename T, access a>
struct _texture2d_array_atomic_store<T, a, typename enable_if<_is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort2 coord, ushort array) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_2d_array_t(derived.t, color, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint2 coord, uint array) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_2d_array_t(derived.t, color, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort2 coord, ushort array) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_2d_array_t(derived.t, color, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint2 coord, uint array) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_2d_array_t(derived.t, color, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort2 coord, ushort array) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_2d_array_t(derived.t, color, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint2 coord, uint array) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_2d_array_t(derived.t, color, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort2 coord, ushort array) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_2d_array_t(derived.t, color, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint2 coord, uint array) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_2d_array_t(derived.t, color, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort2 coord, ushort array) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_2d_array_t(derived.t, color, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint2 coord, uint array) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_2d_array_t(derived.t, color, coord, array, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_array_atomic_compare_exchange
{
};

template <typename T, access a>
struct _texture2d_array_atomic_compare_exchange<T, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC bool atomic_compare_exchange_weak(ushort2 coord, ushort array, thread vec<T, 4> *expected, vec<T, 4> desired) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_2d_array_t(derived.t, coord, array, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint2 coord, uint array, thread vec<T, 4> *expected, vec<T, 4> desired) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_2d_array_t(derived.t, coord, array, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(ushort2 coord, ushort array, thread vec<T, 4> *expected, vec<T, 4> desired) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_2d_array_t(derived.t, coord, array, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint2 coord, uint array, thread vec<T, 4> *expected, vec<T, 4> desired) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_2d_array_t(derived.t, coord, array, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(ushort2 coord, ushort array, thread vec<T, 4> *expected, vec<T, 4> desired) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_2d_array_t(derived.t, coord, array, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint2 coord, uint array, thread vec<T, 4> *expected, vec<T, 4> desired) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_2d_array_t(derived.t, coord, array, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(ushort2 coord, ushort array, thread vec<T, 4> *expected, vec<T, 4> desired) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_2d_array_t(derived.t, coord, array, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint2 coord, uint array, thread vec<T, 4> *expected, vec<T, 4> desired) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_2d_array_t(derived.t, coord, array, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(ushort2 coord, ushort array, thread vec<T, 4> *expected, vec<T, 4> desired) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_2d_array_t(derived.t, coord, array, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint2 coord, uint array, thread vec<T, 4> *expected, vec<T, 4> desired) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_2d_array_t(derived.t, coord, array, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_array_atomic_exchange
{
};

template <typename T, access a>
struct _texture2d_array_atomic_exchange<T, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC vec<T, 4> atomic_exchange(ushort2 coord, ushort array, vec<T, 4> desired) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_2d_array_t(derived.t, coord, array, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint2 coord, uint array, vec<T, 4> desired) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_2d_array_t(derived.t, coord, array, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(ushort2 coord, ushort array, vec<T, 4> desired) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_2d_array_t(derived.t, coord, array, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint2 coord, uint array, vec<T, 4> desired) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_2d_array_t(derived.t, coord, array, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(ushort2 coord, ushort array, vec<T, 4> desired) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_2d_array_t(derived.t, coord, array, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint2 coord, uint array, vec<T, 4> desired) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_2d_array_t(derived.t, coord, array, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(ushort2 coord, ushort array, vec<T, 4> desired) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_2d_array_t(derived.t, coord, array, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint2 coord, uint array, vec<T, 4> desired) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_2d_array_t(derived.t, coord, array, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(ushort2 coord, ushort array, vec<T, 4> desired) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_2d_array_t(derived.t, coord, array, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint2 coord, uint array, vec<T, 4> desired) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_2d_array_t(derived.t, coord, array, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_array_atomic_fetch_and
{
};

template <typename T, access a>
struct _texture2d_array_atomic_fetch_and<T, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort2 coord, ushort array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort2 coord, ushort array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort2 coord, ushort array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort2 coord, ushort array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort2 coord, ushort array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint2 coord, uint array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint2 coord, uint array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint2 coord, uint array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint2 coord, uint array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint2 coord, uint array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort2 coord, ushort array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort2 coord, ushort array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort2 coord, ushort array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort2 coord, ushort array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort2 coord, ushort array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint2 coord, uint array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint2 coord, uint array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint2 coord, uint array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint2 coord, uint array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint2 coord, uint array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort2 coord, ushort array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort2 coord, ushort array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort2 coord, ushort array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort2 coord, ushort array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort2 coord, ushort array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint2 coord, uint array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint2 coord, uint array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint2 coord, uint array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint2 coord, uint array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint2 coord, uint array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort2 coord, ushort array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort2 coord, ushort array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort2 coord, ushort array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort2 coord, ushort array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort2 coord, ushort array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint2 coord, uint array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint2 coord, uint array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint2 coord, uint array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint2 coord, uint array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint2 coord, uint array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort2 coord, ushort array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort2 coord, ushort array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort2 coord, ushort array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort2 coord, ushort array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort2 coord, ushort array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint2 coord, uint array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint2 coord, uint array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint2 coord, uint array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint2 coord, uint array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint2 coord, uint array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_array_atomic_fetch_and_arith
{
};

template <typename T, access a>
struct _texture2d_array_atomic_fetch_and_arith<T, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort2 coord, ushort array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort2 coord, ushort array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint2 coord, uint array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint2 coord, uint array, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort2 coord, ushort array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort2 coord, ushort array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint2 coord, uint array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint2 coord, uint array, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort2 coord, ushort array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort2 coord, ushort array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint2 coord, uint array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint2 coord, uint array, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort2 coord, ushort array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort2 coord, ushort array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint2 coord, uint array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint2 coord, uint array, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort2 coord, ushort array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort2 coord, ushort array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint2 coord, uint array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint2 coord, uint array, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_array_atomic_modify
{
};

template <access a>
struct _texture2d_array_atomic_modify<ulong, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a)>::type>
{
  METAL_FUNC void atomic_max(ushort2 coord, ushort array, ulong4 operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort2 coord, ushort array, ulong4 operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint2 coord, uint array, ulong4 operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint2 coord, uint array, ulong4 operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(ushort2 coord, ushort array, ulong4 operand) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort2 coord, ushort array, ulong4 operand) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint2 coord, uint array, ulong4 operand) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint2 coord, uint array, ulong4 operand) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(ushort2 coord, ushort array, ulong4 operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort2 coord, ushort array, ulong4 operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint2 coord, uint array, ulong4 operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint2 coord, uint array, ulong4 operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(ushort2 coord, ushort array, ulong4 operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort2 coord, ushort array, ulong4 operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint2 coord, uint array, ulong4 operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint2 coord, uint array, ulong4 operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(ushort2 coord, ushort array, ulong4 operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort2 coord, ushort array, ulong4 operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint2 coord, uint array, ulong4 operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint2 coord, uint array, ulong4 operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_2d_array_t(derived.t, coord, array, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};
#endif

template <typename T, access a, typename _Enable = void>
struct _texture2d_array
{
};

template <typename T, access a>
struct _texture2d_array<T, a, typename enable_if<is_color_texture_channel<T>::value>::type>
  : _deleted_operators<texture2d_array<T, a>>
  , _texture2d_array_sample<T, a>
  , _texture2d_array_read<T, a>
  , _texture2d_array_write<T, a>
  , _texture2d_array_gather<T, a>
#if defined(__HAVE_TEXTURE_RELAXED_ORDER_ATOMIC__)
  , _texture2d_array_atomic_load<T, a>
  , _texture2d_array_atomic_store<T, a>
  , _texture2d_array_atomic_compare_exchange<T, a>
  , _texture2d_array_atomic_exchange<T, a>
  , _texture2d_array_atomic_fetch_and<T, a>
  , _texture2d_array_atomic_fetch_and_arith<T, a>
  , _texture2d_array_atomic_modify<T, a>
#endif
{
#if defined(__HAVE_TEXTURE_READWRITE__)
  METAL_FUNC void fence() thread
  {
    thread auto &derived = static_cast<thread texture2d_array<T, a> &>(*this);
    __metal_fence_texture_2d_array_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() device
  {
    device auto &derived = static_cast<device texture2d_array<T, a> &>(*this);
    __metal_fence_texture_2d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() constant
  {
    constant auto &derived = static_cast<constant texture2d_array<T, a> &>(*this);
    __metal_fence_texture_2d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC void fence() ray_data
  {
    ray_data auto &derived = static_cast<ray_data texture2d_array<T, a> &>(*this);
    __metal_fence_texture_2d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC void fence() object_data
  {
    object_data auto &derived = static_cast<object_data texture2d_array<T, a> &>(*this);
    __metal_fence_texture_2d_array_t(derived.t);
  }
#endif
#endif

  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_get_width_texture_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_get_height_texture_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_get_array_size_texture_2d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_2d_array_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_get_width_texture_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_get_height_texture_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_get_array_size_texture_2d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_2d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_get_width_texture_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_get_height_texture_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_get_array_size_texture_2d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_2d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_get_width_texture_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_get_height_texture_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_get_array_size_texture_2d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_2d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_get_width_texture_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_get_height_texture_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_get_array_size_texture_2d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_2d_array_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct texture2d_array : _texture2d_array<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture2d_array'");

  texture2d_array() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  texture2d_array() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  texture2d_array() ray_data = delete;
#endif

  METAL_FUNC texture2d_array(const thread texture2d_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_array(const device texture2d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_array(const constant texture2d_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const ray_data texture2d_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d_array(const object_data texture2d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_array(const thread texture2d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_array(const device texture2d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_array(const constant texture2d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const ray_data texture2d_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d_array(const object_data texture2d_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const thread texture2d_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const device texture2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const constant texture2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const ray_data texture2d_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const object_data texture2d_array &) ray_data = default;
#endif
#endif

  thread texture2d_array &operator=(const thread texture2d_array &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture2d_array &operator=(const device texture2d_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture2d_array &operator=(const constant texture2d_array &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread texture2d_array &operator=(const ray_data texture2d_array &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread texture2d_array &operator=(const object_data texture2d_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture2d_array &operator=(const thread texture2d_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture2d_array &operator=(const device texture2d_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture2d_array &operator=(const constant texture2d_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device texture2d_array &operator=(const ray_data texture2d_array &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device texture2d_array &operator=(const object_data texture2d_array &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_array &operator=(const thread texture2d_array &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_array &operator=(const device texture2d_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_array &operator=(const constant texture2d_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_array &operator=(const ray_data texture2d_array &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_array &operator=(const object_data texture2d_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture2d_array &operator=(const thread texture2d_array &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture2d_array &operator=(const device texture2d_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture2d_array &operator=(const constant texture2d_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data texture2d_array &operator=(const ray_data texture2d_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture2d_array &operator=(const object_data texture2d_array &) object_data = delete;
#endif

private:
  __metal_texture_2d_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture2d_array<T, a>);
#endif
  friend struct _texture2d_array_sample<T, a>;
  friend struct _texture2d_array_read<T, a>;
  friend struct _texture2d_array_write<T, a>;
  friend struct _texture2d_array_gather<T, a>;
#if defined(__HAVE_TEXTURE_RELAXED_ORDER_ATOMIC__)
  friend struct _texture2d_array_atomic_load<T, a>;
  friend struct _texture2d_array_atomic_store<T, a>;
  friend struct _texture2d_array_atomic_compare_exchange<T, a>;
  friend struct _texture2d_array_atomic_exchange<T, a>;
  friend struct _texture2d_array_atomic_fetch_and<T, a>;
  friend struct _texture2d_array_atomic_fetch_and_arith<T, a>;
  friend struct _texture2d_array_atomic_modify<T, a>;
#endif
  friend struct _texture2d_array<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct texture2d_array<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _texture2d_array<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture2d_array'");

  METAL_FUNC texture2d_array() thread : t(__metal_get_null_texture_2d_array_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_array() constant : t(__metal_get_null_texture_2d_array_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array() ray_data : t(__metal_get_null_texture_2d_array_t()) {}
#endif

  METAL_FUNC texture2d_array(const thread texture2d_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_array(const device texture2d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_array(const constant texture2d_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const ray_data texture2d_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d_array(const object_data texture2d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_array(const thread texture2d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_array(const device texture2d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_array(const constant texture2d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const ray_data texture2d_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d_array(const object_data texture2d_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const thread texture2d_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const device texture2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const constant texture2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const ray_data texture2d_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const object_data texture2d_array &) ray_data = default;
#endif
#endif

  METAL_FUNC thread texture2d_array &operator=(const thread texture2d_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture2d_array &operator=(const device texture2d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture2d_array &operator=(const constant texture2d_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread texture2d_array &operator=(const ray_data texture2d_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread texture2d_array &operator=(const object_data texture2d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture2d_array &operator=(const thread texture2d_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture2d_array &operator=(const device texture2d_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture2d_array &operator=(const constant texture2d_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device texture2d_array &operator=(const ray_data texture2d_array &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device texture2d_array &operator=(const object_data texture2d_array &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_array &operator=(const thread texture2d_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_array &operator=(const device texture2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_array &operator=(const constant texture2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_array &operator=(const ray_data texture2d_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_array &operator=(const object_data texture2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_array &operator=(const thread texture2d_array &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_array &operator=(const device texture2d_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_array &operator=(const constant texture2d_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_array &operator=(const ray_data texture2d_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_array &operator=(const object_data texture2d_array &) object_data = default;
#endif

private:
  __metal_texture_2d_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture2d_array<T, a>);
#endif
  friend struct _texture2d_array_sample<T, a>;
  friend struct _texture2d_array_read<T, a>;
  friend struct _texture2d_array_write<T, a>;
  friend struct _texture2d_array_gather<T, a>;
#if defined(__HAVE_TEXTURE_RELAXED_ORDER_ATOMIC__)
  friend struct _texture2d_array_atomic_load<T, a>;
  friend struct _texture2d_array_atomic_store<T, a>;
  friend struct _texture2d_array_atomic_compare_exchange<T, a>;
  friend struct _texture2d_array_atomic_exchange<T, a>;
  friend struct _texture2d_array_atomic_fetch_and<T, a>;
  friend struct _texture2d_array_atomic_fetch_and_arith<T, a>;
  friend struct _texture2d_array_atomic_modify<T, a>;
#endif
  friend struct _texture2d_array<T, a>;
};
#endif

template <typename T, access a, typename _Enable = void>
struct _texture3d_sample
{
};

#if defined(__HAVE_TEXTURE_ULONG_COLOR_CHANNEL__)
template <access a>
struct _texture3d_sample<ulong, a, typename enable_if<_is_valid_sample(a)>::type>
{
};
#endif

template <typename T, access a>
struct _texture3d_sample<T, a, typename enable_if<_is_valid_sample(a)>::type>
{
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, int3 offset = int3(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias options, int3 offset = int3(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, level options, int3 offset = int3(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, min_lod_clamp options, int3 offset = int3(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradient3d options, int3 offset = int3(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradient3d grad_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, int3 offset = int3(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias options, int3 offset = int3(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, level options, int3 offset = int3(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, min_lod_clamp options, int3 offset = int3(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradient3d options, int3 offset = int3(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradient3d grad_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_3d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_3d_t(derived.t, s.val, coord, int(a));
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, int3 offset = int3(0)) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias options, int3 offset = int3(0)) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, level options, int3 offset = int3(0)) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, min_lod_clamp options, int3 offset = int3(0)) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradient3d options, int3 offset = int3(0)) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradient3d grad_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, int3 offset = int3(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias options, int3 offset = int3(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, level options, int3 offset = int3(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, min_lod_clamp options, int3 offset = int3(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradient3d options, int3 offset = int3(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradient3d grad_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_3d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_3d_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, int3 offset = int3(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias options, int3 offset = int3(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, level options, int3 offset = int3(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, min_lod_clamp options, int3 offset = int3(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradient3d options, int3 offset = int3(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradient3d grad_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, int3 offset = int3(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias options, int3 offset = int3(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, level options, int3 offset = int3(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, min_lod_clamp options, int3 offset = int3(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradient3d options, int3 offset = int3(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradient3d grad_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_3d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_3d_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, int3 offset = int3(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias options, int3 offset = int3(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, level options, int3 offset = int3(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, min_lod_clamp options, int3 offset = int3(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradient3d options, int3 offset = int3(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradient3d grad_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, int3 offset = int3(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias options, int3 offset = int3(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, level options, int3 offset = int3(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, min_lod_clamp options, int3 offset = int3(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradient3d options, int3 offset = int3(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradient3d grad_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_3d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_3d_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, int3 offset = int3(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias options, int3 offset = int3(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, level options, int3 offset = int3(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, min_lod_clamp options, int3 offset = int3(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradient3d options, int3 offset = int3(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradient3d grad_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, int3 offset = int3(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias options, int3 offset = int3(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, level options, int3 offset = int3(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, min_lod_clamp options, int3 offset = int3(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradient3d options, int3 offset = int3(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradient3d grad_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_3d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_3d_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture3d_read
{
};

template <typename T, access a>
struct _texture3d_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort3 coord, ushort lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_read_texture_3d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort3 coord, ushort lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_3d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint3 coord, uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_read_texture_3d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint3 coord, uint lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_3d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort3 coord, ushort lod = 0) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_read_texture_3d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort3 coord, ushort lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_3d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint3 coord, uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_read_texture_3d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint3 coord, uint lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_3d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort3 coord, ushort lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_read_texture_3d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort3 coord, ushort lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_3d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint3 coord, uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_read_texture_3d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint3 coord, uint lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_3d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort3 coord, ushort lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_read_texture_3d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort3 coord, ushort lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_3d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint3 coord, uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_read_texture_3d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint3 coord, uint lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_3d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort3 coord, ushort lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_read_texture_3d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort3 coord, ushort lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_3d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint3 coord, uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_read_texture_3d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint3 coord, uint lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_3d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif

};

template <typename T, access a, typename _Enable = void>
struct _texture3d_write
{
};

template <typename T, access a>
struct _texture3d_write<T, a, typename enable_if<_is_valid_write(a)>::type>
{

#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort3 coord, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    __metal_write_texture_3d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort3 coord, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_3d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint3 coord, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    __metal_write_texture_3d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint3 coord, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_3d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort3 coord, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    __metal_write_texture_3d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort3 coord, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_3d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint3 coord, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    __metal_write_texture_3d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint3 coord, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_3d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort3 coord, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    __metal_write_texture_3d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort3 coord, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_3d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint3 coord, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    __metal_write_texture_3d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint3 coord, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_3d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort3 coord, ushort lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    __metal_write_texture_3d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort3 coord, ushort lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_3d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint3 coord, uint lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    __metal_write_texture_3d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint3 coord, uint lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_3d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort3 coord, ushort lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    __metal_write_texture_3d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort3 coord, ushort lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_3d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint3 coord, uint lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    __metal_write_texture_3d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint3 coord, uint lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_3d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif

};

#if defined(__HAVE_TEXTURE_RELAXED_ORDER_ATOMIC__)
template <typename T, access a, typename _Enable = void>
struct _texture3d_atomic_load
{
};

template <typename T, access a>
struct _texture3d_atomic_load<T, a, typename enable_if<_is_valid_read(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC vec<T, 4> atomic_load(ushort3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_3d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_3d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(ushort3 coord) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_3d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint3 coord) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_3d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(ushort3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_3d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_3d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(ushort3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_3d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_3d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(ushort3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_3d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_3d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture3d_atomic_store
{
};

template <typename T, access a>
struct _texture3d_atomic_store<T, a, typename enable_if<_is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_3d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_3d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort3 coord) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_3d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint3 coord) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_3d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_3d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_3d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_3d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_3d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_3d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_3d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture3d_atomic_compare_exchange
{
};

template <typename T, access a>
struct _texture3d_atomic_compare_exchange<T, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC bool atomic_compare_exchange_weak(ushort3 coord, thread vec<T, 4> *expected, vec<T, 4> desired) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_3d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint3 coord, thread vec<T, 4> *expected, vec<T, 4> desired) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_3d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(ushort3 coord, thread vec<T, 4> *expected, vec<T, 4> desired) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_3d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint3 coord, thread vec<T, 4> *expected, vec<T, 4> desired) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_3d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(ushort3 coord, thread vec<T, 4> *expected, vec<T, 4> desired) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_3d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint3 coord, thread vec<T, 4> *expected, vec<T, 4> desired) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_3d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(ushort3 coord, thread vec<T, 4> *expected, vec<T, 4> desired) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_3d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint3 coord, thread vec<T, 4> *expected, vec<T, 4> desired) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_3d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(ushort3 coord, thread vec<T, 4> *expected, vec<T, 4> desired) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_3d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint3 coord, thread vec<T, 4> *expected, vec<T, 4> desired) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_3d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture3d_atomic_exchange
{
};

template <typename T, access a>
struct _texture3d_atomic_exchange<T, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC vec<T, 4> atomic_exchange(ushort3 coord, vec<T, 4> desired) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_3d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint3 coord, vec<T, 4> desired) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_3d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(ushort3 coord, vec<T, 4> desired) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_3d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint3 coord, vec<T, 4> desired) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_3d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(ushort3 coord, vec<T, 4> desired) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_3d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint3 coord, vec<T, 4> desired) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_3d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(ushort3 coord, vec<T, 4> desired) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_3d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint3 coord, vec<T, 4> desired) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_3d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(ushort3 coord, vec<T, 4> desired) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_3d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint3 coord, vec<T, 4> desired) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_3d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture3d_atomic_fetch_and
{
};

template <typename T, access a>
struct _texture3d_atomic_fetch_and<T, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort3 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort3 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort3 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort3 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort3 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint3 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint3 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint3 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint3 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint3 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort3 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort3 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort3 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort3 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort3 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint3 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint3 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint3 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint3 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint3 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort3 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort3 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort3 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort3 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort3 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint3 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint3 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint3 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint3 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint3 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort3 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort3 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort3 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort3 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort3 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint3 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint3 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint3 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint3 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint3 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort3 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort3 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort3 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort3 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort3 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint3 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint3 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint3 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint3 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint3 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture3d_atomic_fetch_and_arith
{
};

template <typename T, access a>
struct _texture3d_atomic_fetch_and_arith<T, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort3 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort3 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint3 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint3 coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort3 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort3 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint3 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint3 coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort3 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort3 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint3 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint3 coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort3 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort3 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint3 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint3 coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort3 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort3 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint3 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint3 coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture3d_atomic_modify
{
};

template <access a>
struct _texture3d_atomic_modify<ulong, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a)>::type>
{
  METAL_FUNC void atomic_max(ushort3 coord, ulong4 operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort3 coord, ulong4 operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint3 coord, ulong4 operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint3 coord, ulong4 operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(ushort3 coord, ulong4 operand) const device
  {
    const device auto &derived = static_cast<const device texture3d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort3 coord, ulong4 operand) const device
  {
    const device auto &derived = static_cast<const device texture3d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint3 coord, ulong4 operand) const device
  {
    const device auto &derived = static_cast<const device texture3d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint3 coord, ulong4 operand) const device
  {
    const device auto &derived = static_cast<const device texture3d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(ushort3 coord, ulong4 operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort3 coord, ulong4 operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint3 coord, ulong4 operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint3 coord, ulong4 operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(ushort3 coord, ulong4 operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort3 coord, ulong4 operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint3 coord, ulong4 operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint3 coord, ulong4 operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(ushort3 coord, ulong4 operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort3 coord, ulong4 operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint3 coord, ulong4 operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint3 coord, ulong4 operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_3d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};
#endif

template <typename T, access a, typename _Enable = void>
struct _texture3d
{
};

template <typename T, access a>
struct _texture3d<T, a, typename enable_if<is_color_texture_channel<T>::value>::type>
  : _deleted_operators<texture3d<T, a>>
  , _texture3d_sample<T, a>
  , _texture3d_read<T, a>
  , _texture3d_write<T, a>
#if defined(__HAVE_TEXTURE_RELAXED_ORDER_ATOMIC__)
  , _texture3d_atomic_load<T, a>
  , _texture3d_atomic_store<T, a>
  , _texture3d_atomic_compare_exchange<T, a>
  , _texture3d_atomic_exchange<T, a>
  , _texture3d_atomic_fetch_and<T, a>
  , _texture3d_atomic_fetch_and_arith<T, a>
  , _texture3d_atomic_modify<T, a>
#endif
{
#if defined(__HAVE_TEXTURE_READWRITE__)
  METAL_FUNC void fence() thread
  {
    thread auto &derived = static_cast<thread texture3d<T, a> &>(*this);
    __metal_fence_texture_3d_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() device
  {
    device auto &derived = static_cast<device texture3d<T, a> &>(*this);
    __metal_fence_texture_3d_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() constant
  {
    constant auto &derived = static_cast<constant texture3d<T, a> &>(*this);
    __metal_fence_texture_3d_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC void fence() ray_data
  {
    ray_data auto &derived = static_cast<ray_data texture3d<T, a> &>(*this);
    __metal_fence_texture_3d_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC void fence() object_data
  {
    object_data auto &derived = static_cast<object_data texture3d<T, a> &>(*this);
    __metal_fence_texture_3d_t(derived.t);
  }
#endif
#endif

  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_get_width_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_get_height_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_depth(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_get_depth_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_3d_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_get_width_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_get_height_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_depth(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_get_depth_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_3d_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_get_width_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_get_height_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_depth(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_get_depth_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_3d_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_get_width_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_get_height_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_depth(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_get_depth_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_3d_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_get_width_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_get_height_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_depth(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_get_depth_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_3d_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct texture3d : _texture3d<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture3d'");

  texture3d() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  texture3d() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  texture3d() ray_data = delete;
#endif

  METAL_FUNC texture3d(const thread texture3d &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture3d(const device texture3d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture3d(const constant texture3d &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const ray_data texture3d &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture3d(const object_data texture3d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture3d(const thread texture3d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture3d(const device texture3d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture3d(const constant texture3d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const ray_data texture3d &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture3d(const object_data texture3d &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const thread texture3d &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const device texture3d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const constant texture3d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const ray_data texture3d &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const object_data texture3d &) ray_data = default;
#endif
#endif

  thread texture3d &operator=(const thread texture3d &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture3d &operator=(const device texture3d &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture3d &operator=(const constant texture3d &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread texture3d &operator=(const ray_data texture3d &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread texture3d &operator=(const object_data texture3d &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture3d &operator=(const thread texture3d &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture3d &operator=(const device texture3d &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture3d &operator=(const constant texture3d &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device texture3d &operator=(const ray_data texture3d &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device texture3d &operator=(const object_data texture3d &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture3d &operator=(const thread texture3d &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture3d &operator=(const device texture3d &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture3d &operator=(const constant texture3d &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture3d &operator=(const ray_data texture3d &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture3d &operator=(const object_data texture3d &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture3d &operator=(const thread texture3d &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture3d &operator=(const device texture3d &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture3d &operator=(const constant texture3d &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data texture3d &operator=(const ray_data texture3d &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture3d &operator=(const object_data texture3d &) object_data = delete;
#endif

private:
  __metal_texture_3d_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture3d<T, a>);
#endif
  friend struct _texture3d_sample<T, a>;
  friend struct _texture3d_read<T, a>;
  friend struct _texture3d_write<T, a>;
#if defined(__HAVE_TEXTURE_RELAXED_ORDER_ATOMIC__)
  friend struct _texture3d_atomic_load<T, a>;
  friend struct _texture3d_atomic_store<T, a>;
  friend struct _texture3d_atomic_compare_exchange<T, a>;
  friend struct _texture3d_atomic_exchange<T, a>;
  friend struct _texture3d_atomic_fetch_and<T, a>;
  friend struct _texture3d_atomic_fetch_and_arith<T, a>;
  friend struct _texture3d_atomic_modify<T, a>;
#endif
  friend struct _texture3d<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct texture3d<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _texture3d<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture3d'");

  METAL_FUNC texture3d() thread : t(__metal_get_null_texture_3d_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture3d() constant : t(__metal_get_null_texture_3d_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d() ray_data : t(__metal_get_null_texture_3d_t()) {}
#endif

  METAL_FUNC texture3d(const thread texture3d &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture3d(const device texture3d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture3d(const constant texture3d &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const ray_data texture3d &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture3d(const object_data texture3d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture3d(const thread texture3d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture3d(const device texture3d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture3d(const constant texture3d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const ray_data texture3d &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture3d(const object_data texture3d &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const thread texture3d &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const device texture3d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const constant texture3d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const ray_data texture3d &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const object_data texture3d &) ray_data = default;
#endif
#endif

  METAL_FUNC thread texture3d &operator=(const thread texture3d &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture3d &operator=(const device texture3d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture3d &operator=(const constant texture3d &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread texture3d &operator=(const ray_data texture3d &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread texture3d &operator=(const object_data texture3d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture3d &operator=(const thread texture3d &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture3d &operator=(const device texture3d &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture3d &operator=(const constant texture3d &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device texture3d &operator=(const ray_data texture3d &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device texture3d &operator=(const object_data texture3d &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture3d &operator=(const thread texture3d &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture3d &operator=(const device texture3d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture3d &operator=(const constant texture3d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture3d &operator=(const ray_data texture3d &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture3d &operator=(const object_data texture3d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture3d &operator=(const thread texture3d &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture3d &operator=(const device texture3d &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture3d &operator=(const constant texture3d &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture3d &operator=(const ray_data texture3d &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture3d &operator=(const object_data texture3d &) object_data = default;
#endif

private:
  __metal_texture_3d_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture3d<T, a>);
#endif
  friend struct _texture3d_sample<T, a>;
  friend struct _texture3d_read<T, a>;
  friend struct _texture3d_write<T, a>;
#if defined(__HAVE_TEXTURE_RELAXED_ORDER_ATOMIC__)
  friend struct _texture3d_atomic_load<T, a>;
  friend struct _texture3d_atomic_store<T, a>;
  friend struct _texture3d_atomic_compare_exchange<T, a>;
  friend struct _texture3d_atomic_exchange<T, a>;
  friend struct _texture3d_atomic_fetch_and<T, a>;
  friend struct _texture3d_atomic_fetch_and_arith<T, a>;
  friend struct _texture3d_atomic_modify<T, a>;
#endif
  friend struct _texture3d<T, a>;
};
#endif

template <typename T, access a, typename _Enable = void>
struct _texturecube_sample
{
};

#if defined(__HAVE_TEXTURE_ULONG_COLOR_CHANNEL__)
template <access a>
struct _texturecube_sample<ulong, a, typename enable_if<_is_valid_sample(a)>::type>
{
};
#endif

template <typename T, access a>
struct _texturecube_sample<T, a, typename enable_if<_is_valid_sample(a)>::type>
{
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias options) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, level options) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, min_lod_clamp options) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradientcube options) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, level options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, min_lod_clamp options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradientcube options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_cube_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_cube_t(derived.t, s.val, coord, int(a));
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord) const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias options) const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, level options) const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, min_lod_clamp options) const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradientcube options) const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, level options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, min_lod_clamp options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradientcube options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_cube_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_cube_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias options) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, level options) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, min_lod_clamp options) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradientcube options) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, level options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, min_lod_clamp options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradientcube options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_cube_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_cube_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, level options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, min_lod_clamp options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradientcube options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, level options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, min_lod_clamp options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradientcube options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_cube_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_cube_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, level options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, min_lod_clamp options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradientcube options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, level options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, min_lod_clamp options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradientcube options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_cube_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_cube_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texturecube_read
{
};

#if defined(__HAVE_TEXTURE_CUBE_READ__)
#if defined(__HAVE_TEXTURE_ULONG_COLOR_CHANNEL__)
template <access a>
struct _texturecube_read<ulong, a, typename enable_if<_is_valid_read(a)>::type>
{
};
#endif

template <typename T, access a>
struct _texturecube_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort face, ushort lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort face, ushort lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint face, uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint face, uint lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort face, ushort lod = 0) const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort face, ushort lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint face, uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint face, uint lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort face, ushort lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort face, ushort lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint face, uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint face, uint lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort face, ushort lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort face, ushort lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint face, uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint face, uint lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort face, ushort lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort face, ushort lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint face, uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint face, uint lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};
#endif

template <typename T, access a, typename _Enable = void>
struct _texturecube_write
{
};

#if defined(__HAVE_TEXTURE_CUBE_WRITE__)
#if defined(__HAVE_TEXTURE_ULONG_COLOR_CHANNEL__)
template <access a>
struct _texturecube_write<ulong, a, typename enable_if<_is_valid_write(a)>::type>
{
};
#endif

template <typename T, access a>
struct _texturecube_write<T, a, typename enable_if<_is_valid_write(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort face, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    __metal_write_texture_cube_t(derived.t, coord, face, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort face, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint face, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    __metal_write_texture_cube_t(derived.t, coord, face, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint face, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort face, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    __metal_write_texture_cube_t(derived.t, coord, face, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort face, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint face, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    __metal_write_texture_cube_t(derived.t, coord, face, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint face, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort face, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    __metal_write_texture_cube_t(derived.t, coord, face, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort face, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint face, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    __metal_write_texture_cube_t(derived.t, coord, face, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint face, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort face, ushort lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    __metal_write_texture_cube_t(derived.t, coord, face, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort face, ushort lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint face, uint lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    __metal_write_texture_cube_t(derived.t, coord, face, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint face, uint lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort face, ushort lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    __metal_write_texture_cube_t(derived.t, coord, face, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort face, ushort lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint face, uint lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    __metal_write_texture_cube_t(derived.t, coord, face, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint face, uint lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
};
#endif

template <typename T, access a, typename _Enable = void>
struct _texturecube_gather
{
};

template <typename T, access a>
struct _texturecube_gather<T, a, typename enable_if<_is_valid_gather(a)>::type>
{
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, component c = component::x) const thread METAL_CONST_ARG(c)
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_gather_texture_cube_t(derived.t, s.val, coord, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, component c = component::x) const thread METAL_CONST_ARG(c)
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_cube_t(derived.t, s.val, coord, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, component c = component::x) const device METAL_CONST_ARG(c)
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_gather_texture_cube_t(derived.t, s.val, coord, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, component c = component::x) const device METAL_CONST_ARG(c)
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_cube_t(derived.t, s.val, coord, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, component c = component::x) const constant METAL_CONST_ARG(c)
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_gather_texture_cube_t(derived.t, s.val, coord, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, component c = component::x) const constant METAL_CONST_ARG(c)
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_cube_t(derived.t, s.val, coord, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, component c = component::x) const ray_data METAL_CONST_ARG(c)
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_gather_texture_cube_t(derived.t, s.val, coord, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, component c = component::x) const ray_data METAL_CONST_ARG(c)
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_cube_t(derived.t, s.val, coord, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, component c = component::x) const object_data METAL_CONST_ARG(c)
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_gather_texture_cube_t(derived.t, s.val, coord, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, component c = component::x) const object_data METAL_CONST_ARG(c)
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_cube_t(derived.t, s.val, coord, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texturecube
{
};

template <typename T, access a>
struct _texturecube<T, a, typename enable_if<is_color_texture_channel<T>::value>::type>
  : _deleted_operators<texturecube<T, a>>
  , _texturecube_sample<T, a>
  , _texturecube_read<T, a>
  , _texturecube_write<T, a>
  , _texturecube_gather<T, a>
{
#if defined(__HAVE_TEXTURE_READWRITE__)
  METAL_FUNC void fence() thread
  {
    thread auto &derived = static_cast<thread texturecube<T, a> &>(*this);
    __metal_fence_texture_cube_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() device
  {
    device auto &derived = static_cast<device texturecube<T, a> &>(*this);
    __metal_fence_texture_cube_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() constant
  {
    constant auto &derived = static_cast<constant texturecube<T, a> &>(*this);
    __metal_fence_texture_cube_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC void fence() ray_data
  {
    ray_data auto &derived = static_cast<ray_data texturecube<T, a> &>(*this);
    __metal_fence_texture_cube_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC void fence() object_data
  {
    object_data auto &derived = static_cast<object_data texturecube<T, a> &>(*this);
    __metal_fence_texture_cube_t(derived.t);
  }
#endif
#endif

  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_get_width_texture_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_get_height_texture_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_cube_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_get_width_texture_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_get_height_texture_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_cube_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_get_width_texture_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_get_height_texture_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_cube_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_get_width_texture_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_get_height_texture_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_cube_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_get_width_texture_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_get_height_texture_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_cube_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct texturecube : _texturecube<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texturecube'");

  texturecube() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  texturecube() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  texturecube() ray_data = delete;
#endif

  METAL_FUNC texturecube(const thread texturecube &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube(const device texturecube &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube(const constant texturecube &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const ray_data texturecube &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texturecube(const object_data texturecube &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube(const thread texturecube &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube(const device texturecube &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube(const constant texturecube &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const ray_data texturecube &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texturecube(const object_data texturecube &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const thread texturecube &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const device texturecube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const constant texturecube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const ray_data texturecube &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const object_data texturecube &) ray_data = default;
#endif
#endif

  thread texturecube &operator=(const thread texturecube &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texturecube &operator=(const device texturecube &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texturecube &operator=(const constant texturecube &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread texturecube &operator=(const ray_data texturecube &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread texturecube &operator=(const object_data texturecube &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texturecube &operator=(const thread texturecube &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texturecube &operator=(const device texturecube &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texturecube &operator=(const constant texturecube &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device texturecube &operator=(const ray_data texturecube &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device texturecube &operator=(const object_data texturecube &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texturecube &operator=(const thread texturecube &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texturecube &operator=(const device texturecube &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texturecube &operator=(const constant texturecube &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texturecube &operator=(const ray_data texturecube &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texturecube &operator=(const object_data texturecube &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texturecube &operator=(const thread texturecube &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texturecube &operator=(const device texturecube &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texturecube &operator=(const constant texturecube &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data texturecube &operator=(const ray_data texturecube &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texturecube &operator=(const object_data texturecube &) object_data = delete;
#endif

private:
  __metal_texture_cube_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texturecube<T, a>);
#endif
  friend struct _texturecube_sample<T, a>;
  friend struct _texturecube_read<T, a>;
  friend struct _texturecube_write<T, a>;
  friend struct _texturecube_gather<T, a>;
  friend struct _texturecube<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct texturecube<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _texturecube<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texturecube'");

  METAL_FUNC texturecube() thread : t(__metal_get_null_texture_cube_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube() constant : t(__metal_get_null_texture_cube_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube() ray_data : t(__metal_get_null_texture_cube_t()) {}
#endif

  METAL_FUNC texturecube(const thread texturecube &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube(const device texturecube &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube(const constant texturecube &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const ray_data texturecube &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texturecube(const object_data texturecube &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube(const thread texturecube &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube(const device texturecube &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube(const constant texturecube &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const ray_data texturecube &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texturecube(const object_data texturecube &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const thread texturecube &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const device texturecube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const constant texturecube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const ray_data texturecube &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const object_data texturecube &) ray_data = default;
#endif
#endif

  METAL_FUNC thread texturecube &operator=(const thread texturecube &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texturecube &operator=(const device texturecube &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texturecube &operator=(const constant texturecube &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread texturecube &operator=(const ray_data texturecube &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread texturecube &operator=(const object_data texturecube &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texturecube &operator=(const thread texturecube &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texturecube &operator=(const device texturecube &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texturecube &operator=(const constant texturecube &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device texturecube &operator=(const ray_data texturecube &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device texturecube &operator=(const object_data texturecube &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texturecube &operator=(const thread texturecube &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texturecube &operator=(const device texturecube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texturecube &operator=(const constant texturecube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texturecube &operator=(const ray_data texturecube &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texturecube &operator=(const object_data texturecube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texturecube &operator=(const thread texturecube &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texturecube &operator=(const device texturecube &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texturecube &operator=(const constant texturecube &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texturecube &operator=(const ray_data texturecube &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texturecube &operator=(const object_data texturecube &) object_data = default;
#endif

private:
  __metal_texture_cube_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texturecube<T, a>);
#endif
  friend struct _texturecube_sample<T, a>;
  friend struct _texturecube_read<T, a>;
  friend struct _texturecube_write<T, a>;
  friend struct _texturecube_gather<T, a>;
  friend struct _texturecube<T, a>;
};
#endif

#if defined(__HAVE_TEXTURE_CUBE_ARRAY__)
template <typename T, access a, typename _Enable = void>
struct _texturecube_array_sample
{
};

#if defined(__HAVE_TEXTURE_ULONG_COLOR_CHANNEL__)
template <access a>
struct _texturecube_array_sample<ulong, a, typename enable_if<_is_valid_sample(a)>::type>
{
};
#endif

template <typename T, access a>
struct _texturecube_array_sample<T, a, typename enable_if<_is_valid_sample(a)>::type>
{
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, bias options) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, level options) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, min_lod_clamp options) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, gradientcube options) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, bias options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, level options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, min_lod_clamp options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, gradientcube options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_cube_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_cube_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array) const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, bias options) const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, level options) const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, min_lod_clamp options) const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, gradientcube options) const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, bias options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, level options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, min_lod_clamp options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, gradientcube options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_cube_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_cube_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, bias options) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, level options) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, min_lod_clamp options) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, gradientcube options) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, bias options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, level options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, min_lod_clamp options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, gradientcube options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_cube_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_cube_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, bias options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, level options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, min_lod_clamp options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, gradientcube options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, bias options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, level options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, min_lod_clamp options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, gradientcube options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_cube_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_cube_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, bias options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, level options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, min_lod_clamp options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, gradientcube options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, bias options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, level options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, min_lod_clamp options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, gradientcube options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_cube_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_cube_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texturecube_array_read
{
};

#if defined(__HAVE_TEXTURE_ULONG_COLOR_CHANNEL__)
template <access a>
struct _texturecube_array_read<ulong, a, typename enable_if<_is_valid_read(a)>::type>
{
};
#endif

template <typename T, access a>
struct _texturecube_array_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint face, uint array, uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint face, uint array, uint lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint face, uint array, uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint face, uint array, uint lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint face, uint array, uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint face, uint array, uint lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint face, uint array, uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint face, uint array, uint lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint face, uint array, uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint face, uint array, uint lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texturecube_array_write
{
};

#if defined(__HAVE_TEXTURE_ULONG_COLOR_CHANNEL__)
template <access a>
struct _texturecube_array_write<ulong, a, typename enable_if<_is_valid_write(a)>::type>
{
};
#endif

template <typename T, access a>
struct _texturecube_array_write<T, a, typename enable_if<_is_valid_write(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort face, ushort array, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    __metal_write_texture_cube_array_t(derived.t, coord, face, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort face, ushort array, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint face, uint array, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    __metal_write_texture_cube_array_t(derived.t, coord, face, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint face, uint array, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort face, ushort array, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    __metal_write_texture_cube_array_t(derived.t, coord, face, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort face, ushort array, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint face, uint array, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    __metal_write_texture_cube_array_t(derived.t, coord, face, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint face, uint array, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort face, ushort array, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    __metal_write_texture_cube_array_t(derived.t, coord, face, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort face, ushort array, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint face, uint array, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    __metal_write_texture_cube_array_t(derived.t, coord, face, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint face, uint array, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort face, ushort array, ushort lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    __metal_write_texture_cube_array_t(derived.t, coord, face, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort face, ushort array, ushort lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint face, uint array, uint lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    __metal_write_texture_cube_array_t(derived.t, coord, face, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint face, uint array, uint lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort face, ushort array, ushort lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    __metal_write_texture_cube_array_t(derived.t, coord, face, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort face, ushort array, ushort lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint face, uint array, uint lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    __metal_write_texture_cube_array_t(derived.t, coord, face, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint face, uint array, uint lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texturecube_array_gather
{
};

template <typename T, access a>
struct _texturecube_array_gather<T, a, typename enable_if<_is_valid_gather(a)>::type>
{
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, uint array, component c = component::x) const thread METAL_CONST_ARG(c)
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_gather_texture_cube_array_t(derived.t, s.val, coord, array, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, uint array, component c = component::x) const thread METAL_CONST_ARG(c)
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_cube_array_t(derived.t, s.val, coord, array, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, uint array, component c = component::x) const device METAL_CONST_ARG(c)
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_gather_texture_cube_array_t(derived.t, s.val, coord, array, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, uint array, component c = component::x) const device METAL_CONST_ARG(c)
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_cube_array_t(derived.t, s.val, coord, array, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, uint array, component c = component::x) const constant METAL_CONST_ARG(c)
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_gather_texture_cube_array_t(derived.t, s.val, coord, array, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, uint array, component c = component::x) const constant METAL_CONST_ARG(c)
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_cube_array_t(derived.t, s.val, coord, array, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, uint array, component c = component::x) const ray_data METAL_CONST_ARG(c)
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_gather_texture_cube_array_t(derived.t, s.val, coord, array, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, uint array, component c = component::x) const ray_data METAL_CONST_ARG(c)
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_cube_array_t(derived.t, s.val, coord, array, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, uint array, component c = component::x) const object_data METAL_CONST_ARG(c)
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_gather_texture_cube_array_t(derived.t, s.val, coord, array, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, uint array, component c = component::x) const object_data METAL_CONST_ARG(c)
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_cube_array_t(derived.t, s.val, coord, array, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texturecube_array
{
};

template <typename T, access a>
struct _texturecube_array<T, a, typename enable_if<is_color_texture_channel<T>::value>::type>
  : _deleted_operators<texturecube_array<T, a>>
  , _texturecube_array_sample<T, a>
  , _texturecube_array_read<T, a>
  , _texturecube_array_write<T, a>
  , _texturecube_array_gather<T, a>
{
#if defined(__HAVE_TEXTURE_READWRITE__)
  METAL_FUNC void fence() thread
  {
    thread auto &derived = static_cast<thread texturecube_array<T, a> &>(*this);
    __metal_fence_texture_cube_array_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() device
  {
    device auto &derived = static_cast<device texturecube_array<T, a> &>(*this);
    __metal_fence_texture_cube_array_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() constant
  {
    constant auto &derived = static_cast<constant texturecube_array<T, a> &>(*this);
    __metal_fence_texture_cube_array_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC void fence() ray_data
  {
    ray_data auto &derived = static_cast<ray_data texturecube_array<T, a> &>(*this);
    __metal_fence_texture_cube_array_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC void fence() object_data
  {
    object_data auto &derived = static_cast<object_data texturecube_array<T, a> &>(*this);
    __metal_fence_texture_cube_array_t(derived.t);
  }
#endif
#endif

  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_get_width_texture_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_get_height_texture_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_get_array_size_texture_cube_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_cube_array_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_get_width_texture_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_get_height_texture_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_get_array_size_texture_cube_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_cube_array_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_get_width_texture_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_get_height_texture_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_get_array_size_texture_cube_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_cube_array_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_get_width_texture_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_get_height_texture_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_get_array_size_texture_cube_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_cube_array_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_get_width_texture_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_get_height_texture_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_get_array_size_texture_cube_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_cube_array_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct texturecube_array : _texturecube_array<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texturecube_array'");

  texturecube_array() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  texturecube_array() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  texturecube_array() ray_data = delete;
#endif

  METAL_FUNC texturecube_array(const thread texturecube_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube_array(const device texturecube_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube_array(const constant texturecube_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const ray_data texturecube_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texturecube_array(const object_data texturecube_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube_array(const thread texturecube_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube_array(const device texturecube_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube_array(const constant texturecube_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const ray_data texturecube_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texturecube_array(const object_data texturecube_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const thread texturecube_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const device texturecube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const constant texturecube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const ray_data texturecube_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const object_data texturecube_array &) ray_data = default;
#endif
#endif

  thread texturecube_array &operator=(const thread texturecube_array &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texturecube_array &operator=(const device texturecube_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texturecube_array &operator=(const constant texturecube_array &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread texturecube_array &operator=(const ray_data texturecube_array &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread texturecube_array &operator=(const object_data texturecube_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texturecube_array &operator=(const thread texturecube_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texturecube_array &operator=(const device texturecube_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texturecube_array &operator=(const constant texturecube_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device texturecube_array &operator=(const ray_data texturecube_array &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device texturecube_array &operator=(const object_data texturecube_array &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texturecube_array &operator=(const thread texturecube_array &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texturecube_array &operator=(const device texturecube_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texturecube_array &operator=(const constant texturecube_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texturecube_array &operator=(const ray_data texturecube_array &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texturecube_array &operator=(const object_data texturecube_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texturecube_array &operator=(const thread texturecube_array &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texturecube_array &operator=(const device texturecube_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texturecube_array &operator=(const constant texturecube_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data texturecube_array &operator=(const ray_data texturecube_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texturecube_array &operator=(const object_data texturecube_array &) object_data = delete;
#endif

private:
  __metal_texture_cube_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texturecube_array<T, a>);
#endif
  friend struct _texturecube_array_sample<T, a>;
  friend struct _texturecube_array_read<T, a>;
  friend struct _texturecube_array_write<T, a>;
  friend struct _texturecube_array_gather<T, a>;
  friend struct _texturecube_array<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct texturecube_array<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _texturecube_array<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texturecube_array'");

  METAL_FUNC texturecube_array() thread : t(__metal_get_null_texture_cube_array_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube_array() constant : t(__metal_get_null_texture_cube_array_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array() ray_data : t(__metal_get_null_texture_cube_array_t()) {}
#endif

  METAL_FUNC texturecube_array(const thread texturecube_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube_array(const device texturecube_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube_array(const constant texturecube_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const ray_data texturecube_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texturecube_array(const object_data texturecube_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube_array(const thread texturecube_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube_array(const device texturecube_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube_array(const constant texturecube_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const ray_data texturecube_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texturecube_array(const object_data texturecube_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const thread texturecube_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const device texturecube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const constant texturecube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const ray_data texturecube_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const object_data texturecube_array &) ray_data = default;
#endif
#endif

  METAL_FUNC thread texturecube_array &operator=(const thread texturecube_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texturecube_array &operator=(const device texturecube_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texturecube_array &operator=(const constant texturecube_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread texturecube_array &operator=(const ray_data texturecube_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread texturecube_array &operator=(const object_data texturecube_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texturecube_array &operator=(const thread texturecube_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texturecube_array &operator=(const device texturecube_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texturecube_array &operator=(const constant texturecube_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device texturecube_array &operator=(const ray_data texturecube_array &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device texturecube_array &operator=(const object_data texturecube_array &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texturecube_array &operator=(const thread texturecube_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texturecube_array &operator=(const device texturecube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texturecube_array &operator=(const constant texturecube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texturecube_array &operator=(const ray_data texturecube_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texturecube_array &operator=(const object_data texturecube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texturecube_array &operator=(const thread texturecube_array &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texturecube_array &operator=(const device texturecube_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texturecube_array &operator=(const constant texturecube_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texturecube_array &operator=(const ray_data texturecube_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texturecube_array &operator=(const object_data texturecube_array &) object_data = default;
#endif

private:
  __metal_texture_cube_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texturecube_array<T, a>);
#endif
  friend struct _texturecube_array_sample<T, a>;
  friend struct _texturecube_array_read<T, a>;
  friend struct _texturecube_array_write<T, a>;
  friend struct _texturecube_array_gather<T, a>;
  friend struct _texturecube_array<T, a>;
};
#endif
#endif

template <typename T, access a, typename _Enable = void>
struct _texture2d_ms_read
{
};

#if defined(__HAVE_TEXTURE_ULONG_COLOR_CHANNEL__)
template <access a>
struct _texture2d_ms_read<ulong, a, typename enable_if<_is_valid_read(a)>::type>
{
};
#endif

template <typename T, access a>
struct _texture2d_ms_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort sample) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_ms<T, a> &>(*this);
    return __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort sample) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_ms<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint sample) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_ms<T, a> &>(*this);
    return __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint sample) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_ms<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort sample) const device
  {
    const device auto &derived = static_cast<const device texture2d_ms<T, a> &>(*this);
    return __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort sample) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_ms<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint sample) const device
  {
    const device auto &derived = static_cast<const device texture2d_ms<T, a> &>(*this);
    return __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint sample) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_ms<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort sample) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_ms<T, a> &>(*this);
    return __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort sample) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_ms<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint sample) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_ms<T, a> &>(*this);
    return __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint sample) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_ms<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort sample) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms<T, a> &>(*this);
    return __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort sample) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint sample) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms<T, a> &>(*this);
    return __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint sample) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort sample) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_ms<T, a> &>(*this);
    return __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort sample) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_ms<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint sample) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_ms<T, a> &>(*this);
    return __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint sample) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_ms<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_ms
{
};

template <typename T, access a>
struct _texture2d_ms<T, a, typename enable_if<is_color_texture_channel<T>::value && _is_valid_ms_access(a)>::type>
  : _deleted_operators<texture2d_ms<T, a>>
  , _texture2d_ms_read<T, a>
{
  METAL_FUNC uint get_width() const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_ms<T, a> &>(*this);
    return __metal_get_width_texture_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_height() const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_ms<T, a> &>(*this);
    return __metal_get_height_texture_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_ms<T, a> &>(*this);
    return __metal_get_num_samples_texture_2d_ms_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width() const device
  {
    const device auto &derived = static_cast<const device texture2d_ms<T, a> &>(*this);
    return __metal_get_width_texture_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_height() const device
  {
    const device auto &derived = static_cast<const device texture2d_ms<T, a> &>(*this);
    return __metal_get_height_texture_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const device
  {
    const device auto &derived = static_cast<const device texture2d_ms<T, a> &>(*this);
    return __metal_get_num_samples_texture_2d_ms_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width() const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_ms<T, a> &>(*this);
    return __metal_get_width_texture_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_height() const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_ms<T, a> &>(*this);
    return __metal_get_height_texture_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_ms<T, a> &>(*this);
    return __metal_get_num_samples_texture_2d_ms_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms<T, a> &>(*this);
    return __metal_get_width_texture_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_height() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms<T, a> &>(*this);
    return __metal_get_height_texture_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms<T, a> &>(*this);
    return __metal_get_num_samples_texture_2d_ms_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_ms<T, a> &>(*this);
    return __metal_get_width_texture_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_height() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_ms<T, a> &>(*this);
    return __metal_get_height_texture_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_ms<T, a> &>(*this);
    return __metal_get_num_samples_texture_2d_ms_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct texture2d_ms : _texture2d_ms<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture2d_ms'");
  static_assert(_is_valid_ms_access(a), "invalid access value 'a' for 'texture2d_ms'");

  texture2d_ms() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  texture2d_ms() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  texture2d_ms() ray_data = delete;
#endif

  METAL_FUNC texture2d_ms(const thread texture2d_ms &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms(const device texture2d_ms &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms(const constant texture2d_ms &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const ray_data texture2d_ms &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d_ms(const object_data texture2d_ms &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms(const thread texture2d_ms &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms(const device texture2d_ms &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms(const constant texture2d_ms &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const ray_data texture2d_ms &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d_ms(const object_data texture2d_ms &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const thread texture2d_ms &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const device texture2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const constant texture2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const ray_data texture2d_ms &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const object_data texture2d_ms &) ray_data = default;
#endif
#endif

  thread texture2d_ms &operator=(const thread texture2d_ms &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture2d_ms &operator=(const device texture2d_ms &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture2d_ms &operator=(const constant texture2d_ms &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread texture2d_ms &operator=(const ray_data texture2d_ms &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread texture2d_ms &operator=(const object_data texture2d_ms &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture2d_ms &operator=(const thread texture2d_ms &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture2d_ms &operator=(const device texture2d_ms &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture2d_ms &operator=(const constant texture2d_ms &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device texture2d_ms &operator=(const ray_data texture2d_ms &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device texture2d_ms &operator=(const object_data texture2d_ms &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_ms &operator=(const thread texture2d_ms &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_ms &operator=(const device texture2d_ms &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_ms &operator=(const constant texture2d_ms &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_ms &operator=(const ray_data texture2d_ms &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_ms &operator=(const object_data texture2d_ms &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture2d_ms &operator=(const thread texture2d_ms &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture2d_ms &operator=(const device texture2d_ms &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture2d_ms &operator=(const constant texture2d_ms &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data texture2d_ms &operator=(const ray_data texture2d_ms &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture2d_ms &operator=(const object_data texture2d_ms &) object_data = delete;
#endif

private:
  __metal_texture_2d_ms_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture2d_ms<T, a>);
#endif
  friend struct _texture2d_ms_read<T, a>;
  friend struct _texture2d_ms<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct texture2d_ms<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _texture2d_ms<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture2d_ms'");
  static_assert(_is_valid_ms_access(a), "invalid access value 'a' for 'texture2d_ms'");

  METAL_FUNC texture2d_ms() thread : t(__metal_get_null_texture_2d_ms_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms() constant : t(__metal_get_null_texture_2d_ms_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms() ray_data : t(__metal_get_null_texture_2d_ms_t()) {}
#endif

  METAL_FUNC texture2d_ms(const thread texture2d_ms &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms(const device texture2d_ms &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms(const constant texture2d_ms &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const ray_data texture2d_ms &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d_ms(const object_data texture2d_ms &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms(const thread texture2d_ms &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms(const device texture2d_ms &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms(const constant texture2d_ms &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const ray_data texture2d_ms &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d_ms(const object_data texture2d_ms &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const thread texture2d_ms &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const device texture2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const constant texture2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const ray_data texture2d_ms &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const object_data texture2d_ms &) ray_data = default;
#endif
#endif

  METAL_FUNC thread texture2d_ms &operator=(const thread texture2d_ms &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture2d_ms &operator=(const device texture2d_ms &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture2d_ms &operator=(const constant texture2d_ms &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread texture2d_ms &operator=(const ray_data texture2d_ms &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread texture2d_ms &operator=(const object_data texture2d_ms &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture2d_ms &operator=(const thread texture2d_ms &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture2d_ms &operator=(const device texture2d_ms &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture2d_ms &operator=(const constant texture2d_ms &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device texture2d_ms &operator=(const ray_data texture2d_ms &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device texture2d_ms &operator=(const object_data texture2d_ms &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_ms &operator=(const thread texture2d_ms &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_ms &operator=(const device texture2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_ms &operator=(const constant texture2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_ms &operator=(const ray_data texture2d_ms &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_ms &operator=(const object_data texture2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_ms &operator=(const thread texture2d_ms &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_ms &operator=(const device texture2d_ms &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_ms &operator=(const constant texture2d_ms &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_ms &operator=(const ray_data texture2d_ms &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_ms &operator=(const object_data texture2d_ms &) object_data = default;
#endif

private:
  __metal_texture_2d_ms_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture2d_ms<T, a>);
#endif
  friend struct _texture2d_ms_read<T, a>;
  friend struct _texture2d_ms<T, a>;
};
#endif

#if defined(__HAVE_TEXTURE_2D_MS_ARRAY__)
template <typename T, access a, typename _Enable = void>
struct _texture2d_ms_array_read
{
};

#if defined(__HAVE_TEXTURE_ULONG_COLOR_CHANNEL__)
template <access a>
struct _texture2d_ms_array_read<ulong, a, typename enable_if<_is_valid_read(a)>::type>
{
};
#endif

template <typename T, access a>
struct _texture2d_ms_array_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort array, ushort sample) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_ms_array<T, a> &>(*this);
    return __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort array, ushort sample) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_ms_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint array, uint sample) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_ms_array<T, a> &>(*this);
    return __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint array, uint sample) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_ms_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort array, ushort sample) const device
  {
    const device auto &derived = static_cast<const device texture2d_ms_array<T, a> &>(*this);
    return __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort array, ushort sample) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_ms_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint array, uint sample) const device
  {
    const device auto &derived = static_cast<const device texture2d_ms_array<T, a> &>(*this);
    return __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint array, uint sample) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_ms_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort array, ushort sample) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_ms_array<T, a> &>(*this);
    return __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort array, ushort sample) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_ms_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint array, uint sample) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_ms_array<T, a> &>(*this);
    return __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint array, uint sample) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_ms_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort array, ushort sample) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms_array<T, a> &>(*this);
    return __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort array, ushort sample) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint array, uint sample) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms_array<T, a> &>(*this);
    return __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint array, uint sample) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort array, ushort sample) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_ms_array<T, a> &>(*this);
    return __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort array, ushort sample) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_ms_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint array, uint sample) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_ms_array<T, a> &>(*this);
    return __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint array, uint sample) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_ms_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_ms_array
{
};

template <typename T, access a>
struct _texture2d_ms_array<T, a, typename enable_if<is_color_texture_channel<T>::value && _is_valid_ms_access(a)>::type>
  : _deleted_operators<texture2d_ms_array<T, a>>
  , _texture2d_ms_array_read<T, a>
{
  METAL_FUNC uint get_width() const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_ms_array<T, a> &>(*this);
    return __metal_get_width_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_height() const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_ms_array<T, a> &>(*this);
    return __metal_get_height_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_array_size() const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_ms_array<T, a> &>(*this);
    return __metal_get_array_size_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_ms_array<T, a> &>(*this);
    return __metal_get_num_samples_texture_2d_ms_array_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width() const device
  {
    const device auto &derived = static_cast<const device texture2d_ms_array<T, a> &>(*this);
    return __metal_get_width_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_height() const device
  {
    const device auto &derived = static_cast<const device texture2d_ms_array<T, a> &>(*this);
    return __metal_get_height_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_array_size() const device
  {
    const device auto &derived = static_cast<const device texture2d_ms_array<T, a> &>(*this);
    return __metal_get_array_size_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const device
  {
    const device auto &derived = static_cast<const device texture2d_ms_array<T, a> &>(*this);
    return __metal_get_num_samples_texture_2d_ms_array_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width() const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_ms_array<T, a> &>(*this);
    return __metal_get_width_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_height() const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_ms_array<T, a> &>(*this);
    return __metal_get_height_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_array_size() const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_ms_array<T, a> &>(*this);
    return __metal_get_array_size_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_ms_array<T, a> &>(*this);
    return __metal_get_num_samples_texture_2d_ms_array_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms_array<T, a> &>(*this);
    return __metal_get_width_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_height() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms_array<T, a> &>(*this);
    return __metal_get_height_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_array_size() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms_array<T, a> &>(*this);
    return __metal_get_array_size_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms_array<T, a> &>(*this);
    return __metal_get_num_samples_texture_2d_ms_array_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_ms_array<T, a> &>(*this);
    return __metal_get_width_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_height() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_ms_array<T, a> &>(*this);
    return __metal_get_height_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_array_size() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_ms_array<T, a> &>(*this);
    return __metal_get_array_size_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_ms_array<T, a> &>(*this);
    return __metal_get_num_samples_texture_2d_ms_array_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct texture2d_ms_array : _texture2d_ms_array<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture2d_ms_array'");
  static_assert(_is_valid_ms_access(a), "invalid access value 'a' for 'texture2d_ms_array'");

  texture2d_ms_array() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  texture2d_ms_array() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  texture2d_ms_array() ray_data = delete;
#endif

  METAL_FUNC texture2d_ms_array(const thread texture2d_ms_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms_array(const device texture2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms_array(const constant texture2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const ray_data texture2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d_ms_array(const object_data texture2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms_array(const thread texture2d_ms_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms_array(const device texture2d_ms_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms_array(const constant texture2d_ms_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const ray_data texture2d_ms_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d_ms_array(const object_data texture2d_ms_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const thread texture2d_ms_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const device texture2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const constant texture2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const ray_data texture2d_ms_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const object_data texture2d_ms_array &) ray_data = default;
#endif
#endif

  thread texture2d_ms_array &operator=(const thread texture2d_ms_array &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture2d_ms_array &operator=(const device texture2d_ms_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture2d_ms_array &operator=(const constant texture2d_ms_array &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread texture2d_ms_array &operator=(const ray_data texture2d_ms_array &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread texture2d_ms_array &operator=(const object_data texture2d_ms_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture2d_ms_array &operator=(const thread texture2d_ms_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture2d_ms_array &operator=(const device texture2d_ms_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture2d_ms_array &operator=(const constant texture2d_ms_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device texture2d_ms_array &operator=(const ray_data texture2d_ms_array &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device texture2d_ms_array &operator=(const object_data texture2d_ms_array &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_ms_array &operator=(const thread texture2d_ms_array &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_ms_array &operator=(const device texture2d_ms_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_ms_array &operator=(const constant texture2d_ms_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_ms_array &operator=(const ray_data texture2d_ms_array &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_ms_array &operator=(const object_data texture2d_ms_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture2d_ms_array &operator=(const thread texture2d_ms_array &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture2d_ms_array &operator=(const device texture2d_ms_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture2d_ms_array &operator=(const constant texture2d_ms_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data texture2d_ms_array &operator=(const ray_data texture2d_ms_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture2d_ms_array &operator=(const object_data texture2d_ms_array &) object_data = delete;
#endif

private:
  __metal_texture_2d_ms_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture2d_ms_array<T, a>);
#endif
  friend struct _texture2d_ms_array_read<T, a>;
  friend struct _texture2d_ms_array<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct texture2d_ms_array<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _texture2d_ms_array<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture2d_ms_array'");
  static_assert(_is_valid_ms_access(a), "invalid access value 'a' for 'texture2d_ms_array'");

  METAL_FUNC texture2d_ms_array() thread : t(__metal_get_null_texture_2d_ms_array_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms_array() constant : t(__metal_get_null_texture_2d_ms_array_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array() ray_data : t(__metal_get_null_texture_2d_ms_array_t()) {}
#endif

  METAL_FUNC texture2d_ms_array(const thread texture2d_ms_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms_array(const device texture2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms_array(const constant texture2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const ray_data texture2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d_ms_array(const object_data texture2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms_array(const thread texture2d_ms_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms_array(const device texture2d_ms_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms_array(const constant texture2d_ms_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const ray_data texture2d_ms_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d_ms_array(const object_data texture2d_ms_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const thread texture2d_ms_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const device texture2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const constant texture2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const ray_data texture2d_ms_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const object_data texture2d_ms_array &) ray_data = default;
#endif
#endif

  METAL_FUNC thread texture2d_ms_array &operator=(const thread texture2d_ms_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture2d_ms_array &operator=(const device texture2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture2d_ms_array &operator=(const constant texture2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread texture2d_ms_array &operator=(const ray_data texture2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread texture2d_ms_array &operator=(const object_data texture2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture2d_ms_array &operator=(const thread texture2d_ms_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture2d_ms_array &operator=(const device texture2d_ms_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture2d_ms_array &operator=(const constant texture2d_ms_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device texture2d_ms_array &operator=(const ray_data texture2d_ms_array &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device texture2d_ms_array &operator=(const object_data texture2d_ms_array &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_ms_array &operator=(const thread texture2d_ms_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_ms_array &operator=(const device texture2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_ms_array &operator=(const constant texture2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_ms_array &operator=(const ray_data texture2d_ms_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_ms_array &operator=(const object_data texture2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_ms_array &operator=(const thread texture2d_ms_array &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_ms_array &operator=(const device texture2d_ms_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_ms_array &operator=(const constant texture2d_ms_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_ms_array &operator=(const ray_data texture2d_ms_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_ms_array &operator=(const object_data texture2d_ms_array &) object_data = default;
#endif

private:
  __metal_texture_2d_ms_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture2d_ms_array<T, a>);
#endif
  friend struct _texture2d_ms_array_read<T, a>;
  friend struct _texture2d_ms_array<T, a>;
};
#endif
#endif

#if defined(__HAVE_TEXTURE_BUFFER__)
template <typename T, access a, typename _Enable = void>
struct _texture_buffer_read
{
};

template <typename T, access a>
struct _texture_buffer_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    return __metal_read_texture_buffer_1d_t(derived.t, coord, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> read(uint coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    return __metal_read_texture_buffer_1d_t(derived.t, coord, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    return __metal_read_texture_buffer_1d_t(derived.t, coord, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> read(uint coord) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    return __metal_read_texture_buffer_1d_t(derived.t, coord, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    return __metal_read_texture_buffer_1d_t(derived.t, coord, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> read(uint coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    return __metal_read_texture_buffer_1d_t(derived.t, coord, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    return __metal_read_texture_buffer_1d_t(derived.t, coord, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> read(uint coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    return __metal_read_texture_buffer_1d_t(derived.t, coord, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    return __metal_read_texture_buffer_1d_t(derived.t, coord, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> read(uint coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    return __metal_read_texture_buffer_1d_t(derived.t, coord, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture_buffer_write
{
};

template <typename T, access a>
struct _texture_buffer_write<T, a, typename enable_if<_is_valid_write(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    __metal_write_texture_buffer_1d_t(derived.t, coord, color, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    __metal_write_texture_buffer_1d_t(derived.t, coord, color, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    __metal_write_texture_buffer_1d_t(derived.t, coord, color, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    __metal_write_texture_buffer_1d_t(derived.t, coord, color, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    __metal_write_texture_buffer_1d_t(derived.t, coord, color, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    __metal_write_texture_buffer_1d_t(derived.t, coord, color, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    __metal_write_texture_buffer_1d_t(derived.t, coord, color, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    __metal_write_texture_buffer_1d_t(derived.t, coord, color, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    __metal_write_texture_buffer_1d_t(derived.t, coord, color, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    __metal_write_texture_buffer_1d_t(derived.t, coord, color, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
};

#if defined(__HAVE_TEXTURE_RELAXED_ORDER_ATOMIC__)
template <typename T, access a, typename _Enable = void>
struct _texture_buffer_atomic_load
{
};

template <typename T, access a>
struct _texture_buffer_atomic_load<T, a, typename enable_if<_is_valid_read(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC vec<T, 4> atomic_load(ushort coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_buffer_1d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_buffer_1d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(ushort coord) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_buffer_1d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint coord) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_buffer_1d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(ushort coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_buffer_1d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_buffer_1d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(ushort coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_buffer_1d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_buffer_1d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(ushort coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_buffer_1d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> atomic_load(uint coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_load_explicit_texture_buffer_1d_t(derived.t, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a), vec<T, 4>());
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture_buffer_atomic_store
{
};

template <typename T, access a>
struct _texture_buffer_atomic_store<T, a, typename enable_if<_is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_buffer_1d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_buffer_1d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort coord) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_buffer_1d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint coord) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_buffer_1d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_buffer_1d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_buffer_1d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_buffer_1d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_buffer_1d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, ushort coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_buffer_1d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_store(vec<T, 4> color, uint coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    __metal_atomic_store_explicit_texture_buffer_1d_t(derived.t, color, coord, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture_buffer_atomic_compare_exchange
{
};

template <typename T, access a>
struct _texture_buffer_atomic_compare_exchange<T, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC bool atomic_compare_exchange_weak(ushort coord, thread vec<T, 4> *expected, vec<T, 4> desired) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_buffer_1d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint coord, thread vec<T, 4> *expected, vec<T, 4> desired) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_buffer_1d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(ushort coord, thread vec<T, 4> *expected, vec<T, 4> desired) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_buffer_1d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint coord, thread vec<T, 4> *expected, vec<T, 4> desired) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_buffer_1d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(ushort coord, thread vec<T, 4> *expected, vec<T, 4> desired) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_buffer_1d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint coord, thread vec<T, 4> *expected, vec<T, 4> desired) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_buffer_1d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(ushort coord, thread vec<T, 4> *expected, vec<T, 4> desired) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_buffer_1d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint coord, thread vec<T, 4> *expected, vec<T, 4> desired) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_buffer_1d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(ushort coord, thread vec<T, 4> *expected, vec<T, 4> desired) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_buffer_1d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC bool atomic_compare_exchange_weak(uint coord, thread vec<T, 4> *expected, vec<T, 4> desired) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_compare_exchange_weak_explicit_texture_buffer_1d_t(derived.t, coord, expected, desired, __METAL_MEMORY_ORDER_RELAXED__, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture_buffer_atomic_exchange
{
};

template <typename T, access a>
struct _texture_buffer_atomic_exchange<T, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC vec<T, 4> atomic_exchange(ushort coord, vec<T, 4> desired) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_buffer_1d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint coord, vec<T, 4> desired) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_buffer_1d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(ushort coord, vec<T, 4> desired) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_buffer_1d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint coord, vec<T, 4> desired) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_buffer_1d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(ushort coord, vec<T, 4> desired) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_buffer_1d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint coord, vec<T, 4> desired) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_buffer_1d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(ushort coord, vec<T, 4> desired) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_buffer_1d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint coord, vec<T, 4> desired) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_buffer_1d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(ushort coord, vec<T, 4> desired) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_buffer_1d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_exchange(uint coord, vec<T, 4> desired) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_exchange_explicit_texture_buffer_1d_t(derived.t, coord, desired, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture_buffer_atomic_fetch_and
{
};

template <typename T, access a>
struct _texture_buffer_atomic_fetch_and<T, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(ushort coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(ushort coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(ushort coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(ushort coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(ushort coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_and(uint coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_and_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_max(uint coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_max_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_min(uint coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_min_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_or(uint coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_or_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_xor(uint coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_xor_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture_buffer_atomic_fetch_and_arith
{
};

template <typename T, access a>
struct _texture_buffer_atomic_fetch_and_arith<T, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a) && _is_color_texture_atomic_channel_type(T)>::type>
{
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint coord, vec<T, 4> operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint coord, vec<T, 4> operand) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint coord, vec<T, 4> operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint coord, vec<T, 4> operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(ushort coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(ushort coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_add(uint coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_add_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC vec<T, 4> atomic_fetch_sub(uint coord, vec<T, 4> operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    return __metal_atomic_fetch_sub_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};

template <typename T, access a, typename _Enable = void>
struct _texture_buffer_atomic_modify
{
};

template <access a>
struct _texture_buffer_atomic_modify<ulong, a, typename enable_if<_is_valid_read(a) && _is_valid_write(a)>::type>
{
  METAL_FUNC void atomic_max(ushort coord, ulong4 operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort coord, ulong4 operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint coord, ulong4 operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint coord, ulong4 operand) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(ushort coord, ulong4 operand) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort coord, ulong4 operand) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint coord, ulong4 operand) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint coord, ulong4 operand) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(ushort coord, ulong4 operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort coord, ulong4 operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint coord, ulong4 operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint coord, ulong4 operand) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(ushort coord, ulong4 operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort coord, ulong4 operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint coord, ulong4 operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint coord, ulong4 operand) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(ushort coord, ulong4 operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(ushort coord, ulong4 operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_max(uint coord, ulong4 operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<ulong, a> &>(*this);
    __metal_atomic_max_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
  METAL_FUNC void atomic_min(uint coord, ulong4 operand) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<ulong, a> &>(*this);
    __metal_atomic_min_explicit_texture_buffer_1d_t(derived.t, coord, operand, __METAL_MEMORY_ORDER_RELAXED__, int(a));
  }
};
#endif

template <typename T, access a, typename _Enable = void>
struct _texture_buffer
{
};

template <typename T, access a>
struct _texture_buffer<T, a, typename enable_if<is_color_texture_channel<T>::value && _is_valid_texture_buffer_access(a)>::type>
  : _deleted_operators<texture_buffer<T, a>>
  , _texture_buffer_read<T, a>
  , _texture_buffer_write<T, a>
#if defined(__HAVE_TEXTURE_RELAXED_ORDER_ATOMIC__)
  , _texture_buffer_atomic_load<T, a>
  , _texture_buffer_atomic_store<T, a>
  , _texture_buffer_atomic_compare_exchange<T, a>
  , _texture_buffer_atomic_exchange<T, a>
  , _texture_buffer_atomic_fetch_and<T, a>
  , _texture_buffer_atomic_fetch_and_arith<T, a>
  , _texture_buffer_atomic_modify<T, a>
#endif
{
  METAL_FUNC void fence() thread
  {
    thread auto &derived = static_cast<thread texture_buffer<T, a> &>(*this);
    __metal_fence_texture_buffer_1d_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() device
  {
    device auto &derived = static_cast<device texture_buffer<T, a> &>(*this);
    __metal_fence_texture_buffer_1d_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() constant
  {
    constant auto &derived = static_cast<constant texture_buffer<T, a> &>(*this);
    __metal_fence_texture_buffer_1d_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC void fence() ray_data
  {
    ray_data auto &derived = static_cast<ray_data texture_buffer<T, a> &>(*this);
    __metal_fence_texture_buffer_1d_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC void fence() object_data
  {
    object_data auto &derived = static_cast<object_data texture_buffer<T, a> &>(*this);
    __metal_fence_texture_buffer_1d_t(derived.t);
  }
#endif

  METAL_FUNC uint get_width() const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    return __metal_get_width_texture_buffer_1d_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width() const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    return __metal_get_width_texture_buffer_1d_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width() const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    return __metal_get_width_texture_buffer_1d_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    return __metal_get_width_texture_buffer_1d_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    return __metal_get_width_texture_buffer_1d_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct texture_buffer : _texture_buffer<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture_buffer'");
  static_assert(_is_valid_texture_buffer_access(a), "invalid access value 'a' for 'texture_buffer'");

  texture_buffer() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  texture_buffer() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  texture_buffer() ray_data = delete;
#endif

  METAL_FUNC texture_buffer(const thread texture_buffer &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture_buffer(const device texture_buffer &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture_buffer(const constant texture_buffer &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const ray_data texture_buffer &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture_buffer(const object_data texture_buffer &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture_buffer(const thread texture_buffer &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture_buffer(const device texture_buffer &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture_buffer(const constant texture_buffer &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const ray_data texture_buffer &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture_buffer(const object_data texture_buffer &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const thread texture_buffer &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const device texture_buffer &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const constant texture_buffer &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const ray_data texture_buffer &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const object_data texture_buffer &) ray_data = default;
#endif
#endif

  thread texture_buffer &operator=(const thread texture_buffer &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture_buffer &operator=(const device texture_buffer &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture_buffer &operator=(const constant texture_buffer &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread texture_buffer &operator=(const ray_data texture_buffer &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread texture_buffer &operator=(const object_data texture_buffer &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture_buffer &operator=(const thread texture_buffer &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture_buffer &operator=(const device texture_buffer &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture_buffer &operator=(const constant texture_buffer &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device texture_buffer &operator=(const ray_data texture_buffer &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device texture_buffer &operator=(const object_data texture_buffer &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture_buffer &operator=(const thread texture_buffer &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture_buffer &operator=(const device texture_buffer &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture_buffer &operator=(const constant texture_buffer &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture_buffer &operator=(const ray_data texture_buffer &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture_buffer &operator=(const object_data texture_buffer &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture_buffer &operator=(const thread texture_buffer &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture_buffer &operator=(const device texture_buffer &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture_buffer &operator=(const constant texture_buffer &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data texture_buffer &operator=(const ray_data texture_buffer &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture_buffer &operator=(const object_data texture_buffer &) object_data = delete;
#endif

private:
  __metal_texture_buffer_1d_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture_buffer<T, a>);
#endif
  friend struct _texture_buffer_read<T, a>;
  friend struct _texture_buffer_write<T, a>;
#if defined(__HAVE_TEXTURE_RELAXED_ORDER_ATOMIC__)
  friend struct _texture_buffer_atomic_load<T, a>;
  friend struct _texture_buffer_atomic_store<T, a>;
  friend struct _texture_buffer_atomic_compare_exchange<T, a>;
  friend struct _texture_buffer_atomic_exchange<T, a>;
  friend struct _texture_buffer_atomic_fetch_and<T, a>;
  friend struct _texture_buffer_atomic_fetch_and_arith<T, a>;
  friend struct _texture_buffer_atomic_modify<T, a>;
#endif
  friend struct _texture_buffer<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct texture_buffer<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _texture_buffer<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture_buffer'");
  static_assert(_is_valid_texture_buffer_access(a), "invalid access value 'a' for 'texture_buffer'");

  METAL_FUNC texture_buffer() thread : t(__metal_get_null_texture_buffer_1d_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture_buffer() constant : t(__metal_get_null_texture_buffer_1d_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer() ray_data : t(__metal_get_null_texture_buffer_1d_t()) {}
#endif

  METAL_FUNC texture_buffer(const thread texture_buffer &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture_buffer(const device texture_buffer &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture_buffer(const constant texture_buffer &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const ray_data texture_buffer &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture_buffer(const object_data texture_buffer &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture_buffer(const thread texture_buffer &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture_buffer(const device texture_buffer &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture_buffer(const constant texture_buffer &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const ray_data texture_buffer &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture_buffer(const object_data texture_buffer &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const thread texture_buffer &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const device texture_buffer &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const constant texture_buffer &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const ray_data texture_buffer &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const object_data texture_buffer &) ray_data = default;
#endif
#endif

  METAL_FUNC thread texture_buffer &operator=(const thread texture_buffer &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture_buffer &operator=(const device texture_buffer &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture_buffer &operator=(const constant texture_buffer &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread texture_buffer &operator=(const ray_data texture_buffer &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread texture_buffer &operator=(const object_data texture_buffer &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture_buffer &operator=(const thread texture_buffer &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture_buffer &operator=(const device texture_buffer &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture_buffer &operator=(const constant texture_buffer &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device texture_buffer &operator=(const ray_data texture_buffer &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device texture_buffer &operator=(const object_data texture_buffer &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture_buffer &operator=(const thread texture_buffer &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture_buffer &operator=(const device texture_buffer &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture_buffer &operator=(const constant texture_buffer &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture_buffer &operator=(const ray_data texture_buffer &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture_buffer &operator=(const object_data texture_buffer &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture_buffer &operator=(const thread texture_buffer &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture_buffer &operator=(const device texture_buffer &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture_buffer &operator=(const constant texture_buffer &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture_buffer &operator=(const ray_data texture_buffer &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture_buffer &operator=(const object_data texture_buffer &) object_data = default;
#endif

private:
  __metal_texture_buffer_1d_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture_buffer<T, a>);
#endif
  friend struct _texture_buffer_read<T, a>;
  friend struct _texture_buffer_write<T, a>;
#if defined(__HAVE_TEXTURE_RELAXED_ORDER_ATOMIC__)
  friend struct _texture_buffer_atomic_load<T, a>;
  friend struct _texture_buffer_atomic_store<T, a>;
  friend struct _texture_buffer_atomic_compare_exchange<T, a>;
  friend struct _texture_buffer_atomic_exchange<T, a>;
  friend struct _texture_buffer_atomic_fetch_and<T, a>;
  friend struct _texture_buffer_atomic_fetch_and_arith<T, a>;
  friend struct _texture_buffer_atomic_modify<T, a>;
#endif
  friend struct _texture_buffer<T, a>;
};
#endif
#endif

template <typename T, access a, typename _Enable = void>
struct _depth2d_sample
{
};

template <typename T, access a>
struct _depth2d_sample<T, a, typename enable_if<_is_valid_sample(a)>::type>
{
  METAL_FUNC T sample(sampler s, float2 coord, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_2d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_2d_t(derived.t, s.val, coord, int(a));
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample(sampler s, float2 coord, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_2d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_2d_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample(sampler s, float2 coord, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_2d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_2d_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC T sample(sampler s, float2 coord, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_2d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_2d_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC T sample(sampler s, float2 coord, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_2d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_2d_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif

  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, bias options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, level options, int2 offset = int2(0)) const thread METAL_VALID_LEVEL_ARG(options)
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, gradient2d options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, bias options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, level options, int2 offset = int2(0)) const thread METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, gradient2d options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, bias options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, level options, int2 offset = int2(0)) const device METAL_VALID_LEVEL_ARG(options)
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, gradient2d options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, bias options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, level options, int2 offset = int2(0)) const device METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, gradient2d options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, bias options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, level options, int2 offset = int2(0)) const constant METAL_VALID_LEVEL_ARG(options)
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, gradient2d options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, bias options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, level options, int2 offset = int2(0)) const constant METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, gradient2d options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, bias options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, level options, int2 offset = int2(0)) const ray_data METAL_VALID_LEVEL_ARG(options)
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, gradient2d options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, bias options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, level options, int2 offset = int2(0)) const ray_data METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, gradient2d options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, bias options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, level options, int2 offset = int2(0)) const object_data METAL_VALID_LEVEL_ARG(options)
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, gradient2d options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, bias options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, level options, int2 offset = int2(0)) const object_data METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, gradient2d options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depth2d_read
{
};

template <typename T, access a>
struct _depth2d_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_read_depth_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_read_depth_2d_t(derived.t, coord, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_read_depth_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_read_depth_2d_t(derived.t, coord, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort lod = 0) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_read_depth_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_read_depth_2d_t(derived.t, coord, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_read_depth_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_read_depth_2d_t(derived.t, coord, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_read_depth_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_read_depth_2d_t(derived.t, coord, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_read_depth_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_read_depth_2d_t(derived.t, coord, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_read_depth_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_read_depth_2d_t(derived.t, coord, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_read_depth_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_read_depth_2d_t(derived.t, coord, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_read_depth_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_read_depth_2d_t(derived.t, coord, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_read_depth_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_read_depth_2d_t(derived.t, coord, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depth2d_gather
{
};

template <typename T, access a>
struct _depth2d_gather<T, a, typename enable_if<_is_valid_gather(a)>::type>
{
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_gather_depth_2d_t(derived.t, s.val, coord, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_2d_t(derived.t, s.val, coord, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_gather_depth_2d_t(derived.t, s.val, coord, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_2d_t(derived.t, s.val, coord, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_gather_depth_2d_t(derived.t, s.val, coord, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_2d_t(derived.t, s.val, coord, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_gather_depth_2d_t(derived.t, s.val, coord, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_2d_t(derived.t, s.val, coord, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_gather_depth_2d_t(derived.t, s.val, coord, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_2d_t(derived.t, s.val, coord, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif

  METAL_FUNC vec<T, 4> gather_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_gather_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_gather_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_gather_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_gather_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_gather_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depth2d
{
};

template <typename T, access a>
struct _depth2d<T, a, typename enable_if<is_depth_texture_channel<T>::value && _is_valid_depth_access(a)>::type>
  : _deleted_operators<depth2d<T, a>>
  , _depth2d_sample<T, a>
  , _depth2d_read<T, a>
  , _depth2d_gather<T, a>
{
  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_get_width_depth_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_get_height_depth_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_2d_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_get_width_depth_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_get_height_depth_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_2d_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_get_width_depth_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_get_height_depth_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_2d_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_get_width_depth_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_get_height_depth_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_2d_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_get_width_depth_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_get_height_depth_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_2d_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct depth2d : _depth2d<T, a>
{
  static_assert(is_depth_texture_channel<T>::value, "invalid channel type 'T' for 'depth2d'");
  static_assert(_is_valid_depth_access(a), "invalid access value 'a' for 'depth2d'");

  depth2d() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  depth2d() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  depth2d() ray_data = delete;
#endif

  METAL_FUNC depth2d(const thread depth2d &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d(const device depth2d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d(const constant depth2d &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const ray_data depth2d &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d(const object_data depth2d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d(const thread depth2d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d(const device depth2d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d(const constant depth2d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const ray_data depth2d &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d(const object_data depth2d &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const thread depth2d &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const device depth2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const constant depth2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const ray_data depth2d &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const object_data depth2d &) ray_data = default;
#endif
#endif

  thread depth2d &operator=(const thread depth2d &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread depth2d &operator=(const device depth2d &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread depth2d &operator=(const constant depth2d &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread depth2d &operator=(const ray_data depth2d &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread depth2d &operator=(const object_data depth2d &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depth2d &operator=(const thread depth2d &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depth2d &operator=(const device depth2d &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depth2d &operator=(const constant depth2d &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device depth2d &operator=(const ray_data depth2d &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device depth2d &operator=(const object_data depth2d &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d &operator=(const thread depth2d &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d &operator=(const device depth2d &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d &operator=(const constant depth2d &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d &operator=(const ray_data depth2d &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d &operator=(const object_data depth2d &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data depth2d &operator=(const thread depth2d &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data depth2d &operator=(const device depth2d &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data depth2d &operator=(const constant depth2d &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data depth2d &operator=(const ray_data depth2d &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data depth2d &operator=(const object_data depth2d &) object_data = delete;
#endif

private:
  __metal_depth_2d_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depth2d<T, a>);
#endif
  friend struct _depth2d_sample<T, a>;
  friend struct _depth2d_read<T, a>;
  friend struct _depth2d_gather<T, a>;
  friend struct _depth2d<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct depth2d<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _depth2d<T, a>
{
  static_assert(is_depth_texture_channel<T>::value, "invalid channel type 'T' for 'depth2d'");
  static_assert(_is_valid_depth_access(a), "invalid access value 'a' for 'depth2d'");

  METAL_FUNC depth2d() thread : t(__metal_get_null_depth_2d_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d() constant : t(__metal_get_null_depth_2d_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d() ray_data : t(__metal_get_null_depth_2d_t()) {}
#endif

  METAL_FUNC depth2d(const thread depth2d &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d(const device depth2d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d(const constant depth2d &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const ray_data depth2d &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d(const object_data depth2d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d(const thread depth2d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d(const device depth2d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d(const constant depth2d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const ray_data depth2d &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d(const object_data depth2d &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const thread depth2d &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const device depth2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const constant depth2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const ray_data depth2d &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const object_data depth2d &) ray_data = default;
#endif
#endif

  METAL_FUNC thread depth2d &operator=(const thread depth2d &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread depth2d &operator=(const device depth2d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread depth2d &operator=(const constant depth2d &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread depth2d &operator=(const ray_data depth2d &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread depth2d &operator=(const object_data depth2d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depth2d &operator=(const thread depth2d &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depth2d &operator=(const device depth2d &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depth2d &operator=(const constant depth2d &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device depth2d &operator=(const ray_data depth2d &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device depth2d &operator=(const object_data depth2d &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d &operator=(const thread depth2d &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d &operator=(const device depth2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d &operator=(const constant depth2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d &operator=(const ray_data depth2d &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d &operator=(const object_data depth2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d &operator=(const thread depth2d &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d &operator=(const device depth2d &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d &operator=(const constant depth2d &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d &operator=(const ray_data depth2d &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d &operator=(const object_data depth2d &) object_data = default;
#endif

private:
  __metal_depth_2d_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depth2d<T, a>);
#endif
  friend struct _depth2d_sample<T, a>;
  friend struct _depth2d_read<T, a>;
  friend struct _depth2d_gather<T, a>;
  friend struct _depth2d<T, a>;
};
#endif

template <typename T, access a, typename _Enable = void>
struct _depth2d_array_sample
{
};

template <typename T, access a>
struct _depth2d_array_sample<T, a, typename enable_if<_is_valid_sample(a)>::type>
{
  METAL_FUNC T sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_2d_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_2d_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_2d_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_2d_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_2d_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_2d_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_2d_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_2d_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_2d_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_2d_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif

  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, bias options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, level options, int2 offset = int2(0)) const thread METAL_VALID_LOD_ARG(options)
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, bias options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, level options, int2 offset = int2(0)) const thread METAL_VALID_LOD_ARG(options)
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, bias options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, level options, int2 offset = int2(0)) const device METAL_VALID_LOD_ARG(options)
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, bias options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, level options, int2 offset = int2(0)) const device METAL_VALID_LOD_ARG(options)
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, bias options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, level options, int2 offset = int2(0)) const constant METAL_VALID_LOD_ARG(options)
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, bias options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, level options, int2 offset = int2(0)) const constant METAL_VALID_LOD_ARG(options)
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, bias options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, level options, int2 offset = int2(0)) const ray_data METAL_VALID_LOD_ARG(options)
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, bias options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, level options, int2 offset = int2(0)) const ray_data METAL_VALID_LOD_ARG(options)
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, bias options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, level options, int2 offset = int2(0)) const object_data METAL_VALID_LOD_ARG(options)
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, bias options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, level options, int2 offset = int2(0)) const object_data METAL_VALID_LOD_ARG(options)
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depth2d_array_read
{
};

template <typename T, access a>
struct _depth2d_array_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort array, ushort lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort array, ushort lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint array, uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint array, uint lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort array, ushort lod = 0) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort array, ushort lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint array, uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint array, uint lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort array, ushort lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort array, ushort lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint array, uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint array, uint lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort array, ushort lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort array, ushort lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint array, uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint array, uint lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort array, ushort lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort array, ushort lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint array, uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint array, uint lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depth2d_array_gather
{
};

template <typename T, access a>
struct _depth2d_array_gather<T, a, typename enable_if<_is_valid_gather(a)>::type>
{
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, uint array, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_gather_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, uint array, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, uint array, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_gather_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, uint array, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, uint array, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_gather_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, uint array, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, uint array, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_gather_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, uint array, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, uint array, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_gather_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, uint array, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif

  METAL_FUNC vec<T, 4> gather_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_gather_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_gather_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_gather_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_gather_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_gather_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depth2d_array
{
};

template <typename T, access a>
struct _depth2d_array<T, a, typename enable_if<is_depth_texture_channel<T>::value && _is_valid_depth_access(a)>::type>
  : _deleted_operators<depth2d_array<T, a>>
  , _depth2d_array_sample<T, a>
  , _depth2d_array_read<T, a>
  , _depth2d_array_gather<T, a>
{
  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_get_width_depth_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_get_height_depth_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_get_array_size_depth_2d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_2d_array_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_get_width_depth_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_get_height_depth_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_get_array_size_depth_2d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_2d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_get_width_depth_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_get_height_depth_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_get_array_size_depth_2d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_2d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_get_width_depth_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_get_height_depth_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_get_array_size_depth_2d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_2d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_get_width_depth_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_get_height_depth_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_get_array_size_depth_2d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_2d_array_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct depth2d_array : _depth2d_array<T, a>
{
  static_assert(is_depth_texture_channel<T>::value, "invalid channel type 'T' for 'depth2d_array'");
  static_assert(_is_valid_depth_access(a), "invalid access value 'a' for 'depth2d_array'");

  depth2d_array() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  depth2d_array() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  depth2d_array() ray_data = delete;
#endif

  METAL_FUNC depth2d_array(const thread depth2d_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_array(const device depth2d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_array(const constant depth2d_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const ray_data depth2d_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d_array(const object_data depth2d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_array(const thread depth2d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_array(const device depth2d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_array(const constant depth2d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const ray_data depth2d_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d_array(const object_data depth2d_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const thread depth2d_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const device depth2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const constant depth2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const ray_data depth2d_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const object_data depth2d_array &) ray_data = default;
#endif
#endif

  thread depth2d_array &operator=(const thread depth2d_array &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread depth2d_array &operator=(const device depth2d_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread depth2d_array &operator=(const constant depth2d_array &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread depth2d_array &operator=(const ray_data depth2d_array &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread depth2d_array &operator=(const object_data depth2d_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depth2d_array &operator=(const thread depth2d_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depth2d_array &operator=(const device depth2d_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depth2d_array &operator=(const constant depth2d_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device depth2d_array &operator=(const ray_data depth2d_array &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device depth2d_array &operator=(const object_data depth2d_array &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_array &operator=(const thread depth2d_array &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_array &operator=(const device depth2d_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_array &operator=(const constant depth2d_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_array &operator=(const ray_data depth2d_array &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_array &operator=(const object_data depth2d_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data depth2d_array &operator=(const thread depth2d_array &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data depth2d_array &operator=(const device depth2d_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data depth2d_array &operator=(const constant depth2d_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data depth2d_array &operator=(const ray_data depth2d_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data depth2d_array &operator=(const object_data depth2d_array &) object_data = delete;
#endif

private:
  __metal_depth_2d_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depth2d_array<T, a>);
#endif
  friend struct _depth2d_array_sample<T, a>;
  friend struct _depth2d_array_read<T, a>;
  friend struct _depth2d_array_gather<T, a>;
  friend struct _depth2d_array<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct depth2d_array<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _depth2d_array<T, a>
{
  static_assert(is_depth_texture_channel<T>::value, "invalid channel type 'T' for 'depth2d_array'");
  static_assert(_is_valid_depth_access(a), "invalid access value 'a' for 'depth2d_array'");

  METAL_FUNC depth2d_array() thread : t(__metal_get_null_depth_2d_array_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_array() constant : t(__metal_get_null_depth_2d_array_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array() ray_data : t(__metal_get_null_depth_2d_array_t()) {}
#endif

  METAL_FUNC depth2d_array(const thread depth2d_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_array(const device depth2d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_array(const constant depth2d_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const ray_data depth2d_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d_array(const object_data depth2d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_array(const thread depth2d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_array(const device depth2d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_array(const constant depth2d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const ray_data depth2d_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d_array(const object_data depth2d_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const thread depth2d_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const device depth2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const constant depth2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const ray_data depth2d_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const object_data depth2d_array &) ray_data = default;
#endif
#endif

  METAL_FUNC thread depth2d_array &operator=(const thread depth2d_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread depth2d_array &operator=(const device depth2d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread depth2d_array &operator=(const constant depth2d_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread depth2d_array &operator=(const ray_data depth2d_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread depth2d_array &operator=(const object_data depth2d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depth2d_array &operator=(const thread depth2d_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depth2d_array &operator=(const device depth2d_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depth2d_array &operator=(const constant depth2d_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device depth2d_array &operator=(const ray_data depth2d_array &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device depth2d_array &operator=(const object_data depth2d_array &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_array &operator=(const thread depth2d_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_array &operator=(const device depth2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_array &operator=(const constant depth2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_array &operator=(const ray_data depth2d_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_array &operator=(const object_data depth2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_array &operator=(const thread depth2d_array &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_array &operator=(const device depth2d_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_array &operator=(const constant depth2d_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_array &operator=(const ray_data depth2d_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_array &operator=(const object_data depth2d_array &) object_data = default;
#endif

private:
  __metal_depth_2d_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depth2d_array<T, a>);
#endif
  friend struct _depth2d_array_sample<T, a>;
  friend struct _depth2d_array_read<T, a>;
  friend struct _depth2d_array_gather<T, a>;
  friend struct _depth2d_array<T, a>;
};
#endif

template <typename T, access a, typename _Enable = void>
struct _depthcube_sample
{
};

template <typename T, access a>
struct _depthcube_sample<T, a, typename enable_if<_is_valid_sample(a)>::type>
{
  METAL_FUNC T sample(sampler s, float3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, bias options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, level options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, min_lod_clamp options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float3 coord, gradientcube options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, bias options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, level options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, min_lod_clamp options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, gradientcube options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_cube_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_cube_t(derived.t, s.val, coord, int(a));
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample(sampler s, float3 coord) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, bias options) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, level options) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, min_lod_clamp options) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float3 coord, gradientcube options) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, bias options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, level options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, min_lod_clamp options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, gradientcube options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_cube_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_cube_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample(sampler s, float3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, bias options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, level options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, min_lod_clamp options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float3 coord, gradientcube options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, bias options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, level options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, min_lod_clamp options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, gradientcube options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_cube_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_cube_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC T sample(sampler s, float3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, bias options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, level options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, min_lod_clamp options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float3 coord, gradientcube options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, bias options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, level options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, min_lod_clamp options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, gradientcube options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_cube_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_cube_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC T sample(sampler s, float3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, bias options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, level options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, min_lod_clamp options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float3 coord, gradientcube options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, bias options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, level options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, min_lod_clamp options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, gradientcube options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_cube_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_cube_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif

  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, bias options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, level options) const thread METAL_VALID_LEVEL_ARG(options)
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, min_lod_clamp options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, gradientcube options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, bias options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, level options) const thread METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, min_lod_clamp options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, gradientcube options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, bias options) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, level options) const device METAL_VALID_LEVEL_ARG(options)
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, min_lod_clamp options) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, gradientcube options) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, bias options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, level options) const device METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, min_lod_clamp options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, gradientcube options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, bias options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, level options) const constant METAL_VALID_LEVEL_ARG(options)
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, min_lod_clamp options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, gradientcube options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, bias options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, level options) const constant METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, min_lod_clamp options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, gradientcube options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, bias options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, level options) const ray_data METAL_VALID_LEVEL_ARG(options)
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, min_lod_clamp options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, gradientcube options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, bias options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, level options) const ray_data METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, min_lod_clamp options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, gradientcube options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, bias options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, level options) const object_data METAL_VALID_LEVEL_ARG(options)
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, min_lod_clamp options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, gradientcube options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, bias options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, level options) const object_data METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, min_lod_clamp options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, gradientcube options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depthcube_read
{
};

template <typename T, access a>
struct _depthcube_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_DEPTH_CUBE_READ__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort face, ushort lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort face, ushort lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint face, uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint face, uint lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort face, ushort lod = 0) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort face, ushort lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint face, uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint face, uint lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort face, ushort lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort face, ushort lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint face, uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint face, uint lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort face, ushort lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort face, ushort lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint face, uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint face, uint lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort face, ushort lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort face, ushort lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint face, uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint face, uint lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depthcube_gather
{
};

template <typename T, access a>
struct _depthcube_gather<T, a, typename enable_if<_is_valid_gather(a)>::type>
{
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_gather_depth_cube_t(derived.t, s.val, coord, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_cube_t(derived.t, s.val, coord, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_gather_depth_cube_t(derived.t, s.val, coord, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_cube_t(derived.t, s.val, coord, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_gather_depth_cube_t(derived.t, s.val, coord, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_cube_t(derived.t, s.val, coord, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_gather_depth_cube_t(derived.t, s.val, coord, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_cube_t(derived.t, s.val, coord, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_gather_depth_cube_t(derived.t, s.val, coord, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_cube_t(derived.t, s.val, coord, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif

  METAL_FUNC vec<T, 4> gather_compare(sampler s, float3 coord, float compare_value) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_gather_compare_depth_cube_t(derived.t, s.val, coord, compare_value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float3 coord, float compare_value) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_cube_t(derived.t, s.val, coord, compare_value, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float3 coord, float compare_value) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_gather_compare_depth_cube_t(derived.t, s.val, coord, compare_value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float3 coord, float compare_value) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_cube_t(derived.t, s.val, coord, compare_value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float3 coord, float compare_value) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_gather_compare_depth_cube_t(derived.t, s.val, coord, compare_value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float3 coord, float compare_value) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_cube_t(derived.t, s.val, coord, compare_value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float3 coord, float compare_value) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_gather_compare_depth_cube_t(derived.t, s.val, coord, compare_value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float3 coord, float compare_value) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_cube_t(derived.t, s.val, coord, compare_value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float3 coord, float compare_value) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_gather_compare_depth_cube_t(derived.t, s.val, coord, compare_value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float3 coord, float compare_value) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_cube_t(derived.t, s.val, coord, compare_value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depthcube
{
};

template <typename T, access a>
struct _depthcube<T, a, typename enable_if<is_depth_texture_channel<T>::value && _is_valid_depth_access(a)>::type>
  : _deleted_operators<depthcube<T, a>>
  , _depthcube_sample<T, a>
  , _depthcube_read<T, a>
  , _depthcube_gather<T, a>
{
  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_get_width_depth_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_get_height_depth_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_cube_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_get_width_depth_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_get_height_depth_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_cube_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_get_width_depth_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_get_height_depth_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_cube_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_get_width_depth_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_get_height_depth_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_cube_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_get_width_depth_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_get_height_depth_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_cube_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct depthcube : _depthcube<T, a>
{
  static_assert(is_depth_texture_channel<T>::value, "invalid channel type 'T' for 'depthcube'");
  static_assert(_is_valid_depth_access(a), "invalid access value 'a' for 'depthcube'");

  depthcube() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  depthcube() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  depthcube() ray_data = delete;
#endif

  METAL_FUNC depthcube(const thread depthcube &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube(const device depthcube &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube(const constant depthcube &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const ray_data depthcube &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC depthcube(const object_data depthcube &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube(const thread depthcube &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube(const device depthcube &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube(const constant depthcube &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const ray_data depthcube &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC depthcube(const object_data depthcube &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const thread depthcube &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const device depthcube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const constant depthcube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const ray_data depthcube &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const object_data depthcube &) ray_data = default;
#endif
#endif

  thread depthcube &operator=(const thread depthcube &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread depthcube &operator=(const device depthcube &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread depthcube &operator=(const constant depthcube &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread depthcube &operator=(const ray_data depthcube &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread depthcube &operator=(const object_data depthcube &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depthcube &operator=(const thread depthcube &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depthcube &operator=(const device depthcube &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depthcube &operator=(const constant depthcube &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device depthcube &operator=(const ray_data depthcube &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device depthcube &operator=(const object_data depthcube &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data depthcube &operator=(const thread depthcube &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depthcube &operator=(const device depthcube &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depthcube &operator=(const constant depthcube &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data depthcube &operator=(const ray_data depthcube &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depthcube &operator=(const object_data depthcube &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data depthcube &operator=(const thread depthcube &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data depthcube &operator=(const device depthcube &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data depthcube &operator=(const constant depthcube &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data depthcube &operator=(const ray_data depthcube &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data depthcube &operator=(const object_data depthcube &) object_data = delete;
#endif

private:
  __metal_depth_cube_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depthcube<T, a>);
#endif
  friend struct _depthcube_sample<T, a>;
  friend struct _depthcube_read<T, a>;
  friend struct _depthcube_gather<T, a>;
  friend struct _depthcube<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct depthcube<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _depthcube<T, a>
{
  static_assert(is_depth_texture_channel<T>::value, "invalid channel type 'T' for 'depthcube'");
  static_assert(_is_valid_depth_access(a), "invalid access value 'a' for 'depthcube'");

  METAL_FUNC depthcube() thread : t(__metal_get_null_depth_cube_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube() constant : t(__metal_get_null_depth_cube_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube() ray_data : t(__metal_get_null_depth_cube_t()) {}
#endif

  METAL_FUNC depthcube(const thread depthcube &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube(const device depthcube &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube(const constant depthcube &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const ray_data depthcube &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC depthcube(const object_data depthcube &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube(const thread depthcube &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube(const device depthcube &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube(const constant depthcube &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const ray_data depthcube &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC depthcube(const object_data depthcube &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const thread depthcube &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const device depthcube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const constant depthcube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const ray_data depthcube &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const object_data depthcube &) ray_data = default;
#endif
#endif

  METAL_FUNC thread depthcube &operator=(const thread depthcube &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread depthcube &operator=(const device depthcube &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread depthcube &operator=(const constant depthcube &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread depthcube &operator=(const ray_data depthcube &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread depthcube &operator=(const object_data depthcube &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depthcube &operator=(const thread depthcube &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depthcube &operator=(const device depthcube &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depthcube &operator=(const constant depthcube &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device depthcube &operator=(const ray_data depthcube &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device depthcube &operator=(const object_data depthcube &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depthcube &operator=(const thread depthcube &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depthcube &operator=(const device depthcube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depthcube &operator=(const constant depthcube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depthcube &operator=(const ray_data depthcube &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depthcube &operator=(const object_data depthcube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depthcube &operator=(const thread depthcube &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depthcube &operator=(const device depthcube &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depthcube &operator=(const constant depthcube &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depthcube &operator=(const ray_data depthcube &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depthcube &operator=(const object_data depthcube &) object_data = default;
#endif

private:
  __metal_depth_cube_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depthcube<T, a>);
#endif
  friend struct _depthcube_sample<T, a>;
  friend struct _depthcube_read<T, a>;
  friend struct _depthcube_gather<T, a>;
  friend struct _depthcube<T, a>;
};
#endif

#if defined(__HAVE_DEPTH_CUBE_ARRAY__)
template <typename T, access a, typename _Enable = void>
struct _depthcube_array_sample
{
};

template <typename T, access a>
struct _depthcube_array_sample<T, a, typename enable_if<_is_valid_sample(a)>::type>
{
  METAL_FUNC T sample(sampler s, float3 coord, uint array) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, bias options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, level options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array, min_lod_clamp options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float3 coord, uint array, gradientcube options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, bias options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, level options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, min_lod_clamp options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, gradientcube options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_cube_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_cube_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, bias options) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, level options) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array, min_lod_clamp options) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float3 coord, uint array, gradientcube options) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, bias options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, level options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, min_lod_clamp options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, gradientcube options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_cube_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_cube_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, bias options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, level options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array, min_lod_clamp options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float3 coord, uint array, gradientcube options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, bias options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, level options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, min_lod_clamp options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, gradientcube options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_cube_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_cube_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, bias options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, level options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array, min_lod_clamp options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float3 coord, uint array, gradientcube options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, bias options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, level options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, min_lod_clamp options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, gradientcube options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_cube_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_cube_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, bias options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, level options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array, min_lod_clamp options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float3 coord, uint array, gradientcube options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, bias options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, level options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, min_lod_clamp options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, gradientcube options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_cube_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_cube_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif

  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, bias options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, level options) const thread METAL_VALID_LEVEL_ARG(options)
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, min_lod_clamp options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, bias options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, level options) const thread METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, min_lod_clamp options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, bias options) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, level options) const device METAL_VALID_LEVEL_ARG(options)
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, min_lod_clamp options) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube options) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, bias options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, level options) const device METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, min_lod_clamp options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, bias options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, level options) const constant METAL_VALID_LEVEL_ARG(options)
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, min_lod_clamp options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, bias options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, level options) const constant METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, min_lod_clamp options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, bias options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, level options) const ray_data METAL_VALID_LEVEL_ARG(options)
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, min_lod_clamp options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, bias options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, level options) const ray_data METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, min_lod_clamp options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, bias options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, level options) const object_data METAL_VALID_LEVEL_ARG(options)
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, min_lod_clamp options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, bias options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, level options) const object_data METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, min_lod_clamp options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depthcube_array_read
{
};

template <typename T, access a>
struct _depthcube_array_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint face, uint array, uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint face, uint array, uint lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint face, uint array, uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint face, uint array, uint lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint face, uint array, uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint face, uint array, uint lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint face, uint array, uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint face, uint array, uint lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint face, uint array, uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint face, uint array, uint lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depthcube_array_gather
{
};

template <typename T, access a>
struct _depthcube_array_gather<T, a, typename enable_if<_is_valid_gather(a)>::type>
{
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, uint array) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_gather_depth_cube_array_t(derived.t, s.val, coord, array, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, uint array) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_cube_array_t(derived.t, s.val, coord, array, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, uint array) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_gather_depth_cube_array_t(derived.t, s.val, coord, array, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, uint array) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_cube_array_t(derived.t, s.val, coord, array, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, uint array) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_gather_depth_cube_array_t(derived.t, s.val, coord, array, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, uint array) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_cube_array_t(derived.t, s.val, coord, array, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, uint array) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_gather_depth_cube_array_t(derived.t, s.val, coord, array, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, uint array) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_cube_array_t(derived.t, s.val, coord, array, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, uint array) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_gather_depth_cube_array_t(derived.t, s.val, coord, array, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, uint array) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_cube_array_t(derived.t, s.val, coord, array, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif

  METAL_FUNC vec<T, 4> gather_compare(sampler s, float3 coord, uint array, float compare_value) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_gather_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float3 coord, uint array, float compare_value) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float3 coord, uint array, float compare_value) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_gather_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float3 coord, uint array, float compare_value) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float3 coord, uint array, float compare_value) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_gather_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float3 coord, uint array, float compare_value) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float3 coord, uint array, float compare_value) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_gather_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float3 coord, uint array, float compare_value) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float3 coord, uint array, float compare_value) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_gather_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float3 coord, uint array, float compare_value) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depthcube_array
{
};

template <typename T, access a>
struct _depthcube_array<T, a, typename enable_if<is_depth_texture_channel<T>::value && _is_valid_depth_access(a)>::type>
  : _deleted_operators<depthcube_array<T, a>>
  , _depthcube_array_sample<T, a>
  , _depthcube_array_read<T, a>
  , _depthcube_array_gather<T, a>
{
  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_get_width_depth_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_get_height_depth_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_get_array_size_depth_cube_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_cube_array_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_get_width_depth_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_get_height_depth_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_get_array_size_depth_cube_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_cube_array_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_get_width_depth_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_get_height_depth_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_get_array_size_depth_cube_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_cube_array_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_get_width_depth_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_get_height_depth_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_get_array_size_depth_cube_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_cube_array_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_get_width_depth_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_get_height_depth_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_get_array_size_depth_cube_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_cube_array_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct depthcube_array : _depthcube_array<T, a>
{
  static_assert(is_depth_texture_channel<T>::value, "invalid channel type 'T' for 'depthcube_array'");
  static_assert(_is_valid_depth_access(a), "invalid access value 'a' for 'depthcube_array'");

  depthcube_array() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  depthcube_array() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  depthcube_array() ray_data = delete;
#endif

  METAL_FUNC depthcube_array(const thread depthcube_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube_array(const device depthcube_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube_array(const constant depthcube_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const ray_data depthcube_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC depthcube_array(const object_data depthcube_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube_array(const thread depthcube_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube_array(const device depthcube_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube_array(const constant depthcube_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const ray_data depthcube_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC depthcube_array(const object_data depthcube_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const thread depthcube_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const device depthcube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const constant depthcube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const ray_data depthcube_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const object_data depthcube_array &) ray_data = default;
#endif
#endif

  thread depthcube_array &operator=(const thread depthcube_array &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread depthcube_array &operator=(const device depthcube_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread depthcube_array &operator=(const constant depthcube_array &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread depthcube_array &operator=(const ray_data depthcube_array &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread depthcube_array &operator=(const object_data depthcube_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depthcube_array &operator=(const thread depthcube_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depthcube_array &operator=(const device depthcube_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depthcube_array &operator=(const constant depthcube_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device depthcube_array &operator=(const ray_data depthcube_array &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device depthcube_array &operator=(const object_data depthcube_array &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data depthcube_array &operator=(const thread depthcube_array &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depthcube_array &operator=(const device depthcube_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depthcube_array &operator=(const constant depthcube_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data depthcube_array &operator=(const ray_data depthcube_array &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depthcube_array &operator=(const object_data depthcube_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data depthcube_array &operator=(const thread depthcube_array &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data depthcube_array &operator=(const device depthcube_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data depthcube_array &operator=(const constant depthcube_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data depthcube_array &operator=(const ray_data depthcube_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data depthcube_array &operator=(const object_data depthcube_array &) object_data = delete;
#endif

private:
  __metal_depth_cube_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depthcube_array<T, a>);
#endif
  friend struct _depthcube_array_sample<T, a>;
  friend struct _depthcube_array_read<T, a>;
  friend struct _depthcube_array_gather<T, a>;
  friend struct _depthcube_array<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct depthcube_array<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _depthcube_array<T, a>
{
  static_assert(is_depth_texture_channel<T>::value, "invalid channel type 'T' for 'depthcube_array'");
  static_assert(_is_valid_depth_access(a), "invalid access value 'a' for 'depthcube_array'");

  METAL_FUNC depthcube_array() thread : t(__metal_get_null_depth_cube_array_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube_array() constant : t(__metal_get_null_depth_cube_array_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array() ray_data : t(__metal_get_null_depth_cube_array_t()) {}
#endif

  METAL_FUNC depthcube_array(const thread depthcube_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube_array(const device depthcube_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube_array(const constant depthcube_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const ray_data depthcube_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC depthcube_array(const object_data depthcube_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube_array(const thread depthcube_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube_array(const device depthcube_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube_array(const constant depthcube_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const ray_data depthcube_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC depthcube_array(const object_data depthcube_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const thread depthcube_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const device depthcube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const constant depthcube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const ray_data depthcube_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const object_data depthcube_array &) ray_data = default;
#endif
#endif

  METAL_FUNC thread depthcube_array &operator=(const thread depthcube_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread depthcube_array &operator=(const device depthcube_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread depthcube_array &operator=(const constant depthcube_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread depthcube_array &operator=(const ray_data depthcube_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread depthcube_array &operator=(const object_data depthcube_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depthcube_array &operator=(const thread depthcube_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depthcube_array &operator=(const device depthcube_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depthcube_array &operator=(const constant depthcube_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device depthcube_array &operator=(const ray_data depthcube_array &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device depthcube_array &operator=(const object_data depthcube_array &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depthcube_array &operator=(const thread depthcube_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depthcube_array &operator=(const device depthcube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depthcube_array &operator=(const constant depthcube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depthcube_array &operator=(const ray_data depthcube_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depthcube_array &operator=(const object_data depthcube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depthcube_array &operator=(const thread depthcube_array &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depthcube_array &operator=(const device depthcube_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depthcube_array &operator=(const constant depthcube_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depthcube_array &operator=(const ray_data depthcube_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depthcube_array &operator=(const object_data depthcube_array &) object_data = default;
#endif

private:
  __metal_depth_cube_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depthcube_array<T, a>);
#endif
  friend struct _depthcube_array_sample<T, a>;
  friend struct _depthcube_array_read<T, a>;
  friend struct _depthcube_array_gather<T, a>;
  friend struct _depthcube_array<T, a>;
};
#endif
#endif

template <typename T, access a, typename _Enable = void>
struct _depth2d_ms_read
{
};

template <typename T, access a>
struct _depth2d_ms_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort sample) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_ms<T, a> &>(*this);
    return __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort sample) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_ms<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint sample) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_ms<T, a> &>(*this);
    return __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint sample) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_ms<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort sample) const device
  {
    const device auto &derived = static_cast<const device depth2d_ms<T, a> &>(*this);
    return __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort sample) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_ms<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint sample) const device
  {
    const device auto &derived = static_cast<const device depth2d_ms<T, a> &>(*this);
    return __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint sample) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_ms<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort sample) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_ms<T, a> &>(*this);
    return __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort sample) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_ms<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint sample) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_ms<T, a> &>(*this);
    return __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint sample) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_ms<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort sample) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms<T, a> &>(*this);
    return __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort sample) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint sample) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms<T, a> &>(*this);
    return __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint sample) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort sample) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_ms<T, a> &>(*this);
    return __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort sample) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_ms<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint sample) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_ms<T, a> &>(*this);
    return __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint sample) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_ms<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depth2d_ms
{
};

template <typename T, access a>
struct _depth2d_ms<T, a, typename enable_if<is_depth_texture_channel<T>::value && _is_valid_depth_access(a)>::type>
  : _deleted_operators<depth2d_ms<T, a>>
  , _depth2d_ms_read<T, a>
{
  METAL_FUNC uint get_width() const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_ms<T, a> &>(*this);
    return __metal_get_width_depth_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_height() const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_ms<T, a> &>(*this);
    return __metal_get_height_depth_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_ms<T, a> &>(*this);
    return __metal_get_num_samples_depth_2d_ms_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width() const device
  {
    const device auto &derived = static_cast<const device depth2d_ms<T, a> &>(*this);
    return __metal_get_width_depth_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_height() const device
  {
    const device auto &derived = static_cast<const device depth2d_ms<T, a> &>(*this);
    return __metal_get_height_depth_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const device
  {
    const device auto &derived = static_cast<const device depth2d_ms<T, a> &>(*this);
    return __metal_get_num_samples_depth_2d_ms_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width() const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_ms<T, a> &>(*this);
    return __metal_get_width_depth_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_height() const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_ms<T, a> &>(*this);
    return __metal_get_height_depth_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_ms<T, a> &>(*this);
    return __metal_get_num_samples_depth_2d_ms_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms<T, a> &>(*this);
    return __metal_get_width_depth_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_height() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms<T, a> &>(*this);
    return __metal_get_height_depth_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms<T, a> &>(*this);
    return __metal_get_num_samples_depth_2d_ms_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width() const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_ms<T, a> &>(*this);
    return __metal_get_width_depth_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_height() const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_ms<T, a> &>(*this);
    return __metal_get_height_depth_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_ms<T, a> &>(*this);
    return __metal_get_num_samples_depth_2d_ms_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct depth2d_ms : _depth2d_ms<T, a>
{
  static_assert(is_depth_texture_channel<T>::value, "invalid channel type 'T' for 'depth2d_ms'");
  static_assert(_is_valid_depth_access(a), "invalid access value 'a' for 'depth2d_ms'");

  depth2d_ms() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  depth2d_ms() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  depth2d_ms() ray_data = delete;
#endif

  METAL_FUNC depth2d_ms(const thread depth2d_ms &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms(const device depth2d_ms &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms(const constant depth2d_ms &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const ray_data depth2d_ms &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d_ms(const object_data depth2d_ms &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms(const thread depth2d_ms &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms(const device depth2d_ms &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms(const constant depth2d_ms &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const ray_data depth2d_ms &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d_ms(const object_data depth2d_ms &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const thread depth2d_ms &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const device depth2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const constant depth2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const ray_data depth2d_ms &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const object_data depth2d_ms &) ray_data = default;
#endif
#endif

  thread depth2d_ms &operator=(const thread depth2d_ms &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread depth2d_ms &operator=(const device depth2d_ms &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread depth2d_ms &operator=(const constant depth2d_ms &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread depth2d_ms &operator=(const ray_data depth2d_ms &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread depth2d_ms &operator=(const object_data depth2d_ms &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depth2d_ms &operator=(const thread depth2d_ms &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depth2d_ms &operator=(const device depth2d_ms &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depth2d_ms &operator=(const constant depth2d_ms &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device depth2d_ms &operator=(const ray_data depth2d_ms &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device depth2d_ms &operator=(const object_data depth2d_ms &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_ms &operator=(const thread depth2d_ms &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_ms &operator=(const device depth2d_ms &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_ms &operator=(const constant depth2d_ms &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_ms &operator=(const ray_data depth2d_ms &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_ms &operator=(const object_data depth2d_ms &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data depth2d_ms &operator=(const thread depth2d_ms &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data depth2d_ms &operator=(const device depth2d_ms &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data depth2d_ms &operator=(const constant depth2d_ms &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data depth2d_ms &operator=(const ray_data depth2d_ms &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data depth2d_ms &operator=(const object_data depth2d_ms &) object_data = delete;
#endif

private:
  __metal_depth_2d_ms_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depth2d_ms<T, a>);
#endif
  friend struct _depth2d_ms_read<T, a>;
  friend struct _depth2d_ms<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct depth2d_ms<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _depth2d_ms<T, a>
{
  static_assert(is_depth_texture_channel<T>::value, "invalid channel type 'T' for 'depth2d_ms'");
  static_assert(_is_valid_depth_access(a), "invalid access value 'a' for 'depth2d_ms'");

  METAL_FUNC depth2d_ms() thread : t(__metal_get_null_depth_2d_ms_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms() constant : t(__metal_get_null_depth_2d_ms_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms() ray_data : t(__metal_get_null_depth_2d_ms_t()) {}
#endif

  METAL_FUNC depth2d_ms(const thread depth2d_ms &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms(const device depth2d_ms &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms(const constant depth2d_ms &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const ray_data depth2d_ms &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d_ms(const object_data depth2d_ms &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms(const thread depth2d_ms &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms(const device depth2d_ms &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms(const constant depth2d_ms &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const ray_data depth2d_ms &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d_ms(const object_data depth2d_ms &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const thread depth2d_ms &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const device depth2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const constant depth2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const ray_data depth2d_ms &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const object_data depth2d_ms &) ray_data = default;
#endif
#endif

  METAL_FUNC thread depth2d_ms &operator=(const thread depth2d_ms &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread depth2d_ms &operator=(const device depth2d_ms &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread depth2d_ms &operator=(const constant depth2d_ms &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread depth2d_ms &operator=(const ray_data depth2d_ms &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread depth2d_ms &operator=(const object_data depth2d_ms &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depth2d_ms &operator=(const thread depth2d_ms &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depth2d_ms &operator=(const device depth2d_ms &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depth2d_ms &operator=(const constant depth2d_ms &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device depth2d_ms &operator=(const ray_data depth2d_ms &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device depth2d_ms &operator=(const object_data depth2d_ms &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_ms &operator=(const thread depth2d_ms &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_ms &operator=(const device depth2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_ms &operator=(const constant depth2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_ms &operator=(const ray_data depth2d_ms &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_ms &operator=(const object_data depth2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_ms &operator=(const thread depth2d_ms &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_ms &operator=(const device depth2d_ms &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_ms &operator=(const constant depth2d_ms &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_ms &operator=(const ray_data depth2d_ms &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_ms &operator=(const object_data depth2d_ms &) object_data = default;
#endif

private:
  __metal_depth_2d_ms_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depth2d_ms<T, a>);
#endif
  friend struct _depth2d_ms_read<T, a>;
  friend struct _depth2d_ms<T, a>;
};
#endif

#if defined(__HAVE_DEPTH_2D_MS_ARRAY__)
template <typename T, access a, typename _Enable = void>
struct _depth2d_ms_array_read
{
};

template <typename T, access a>
struct _depth2d_ms_array_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort array, ushort sample) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_ms_array<T, a> &>(*this);
    return __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort array, ushort sample) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_ms_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint array, uint sample) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_ms_array<T, a> &>(*this);
    return __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint array, uint sample) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_ms_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort array, ushort sample) const device
  {
    const device auto &derived = static_cast<const device depth2d_ms_array<T, a> &>(*this);
    return __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort array, ushort sample) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_ms_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint array, uint sample) const device
  {
    const device auto &derived = static_cast<const device depth2d_ms_array<T, a> &>(*this);
    return __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint array, uint sample) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_ms_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort array, ushort sample) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_ms_array<T, a> &>(*this);
    return __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort array, ushort sample) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_ms_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint array, uint sample) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_ms_array<T, a> &>(*this);
    return __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint array, uint sample) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_ms_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort array, ushort sample) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms_array<T, a> &>(*this);
    return __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort array, ushort sample) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint array, uint sample) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms_array<T, a> &>(*this);
    return __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint array, uint sample) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort array, ushort sample) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_ms_array<T, a> &>(*this);
    return __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort array, ushort sample) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_ms_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint array, uint sample) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_ms_array<T, a> &>(*this);
    return __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint array, uint sample) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_ms_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depth2d_ms_array
{
};

template <typename T, access a>
struct _depth2d_ms_array<T, a, typename enable_if<is_depth_texture_channel<T>::value && _is_valid_depth_access(a)>::type>
  : _deleted_operators<depth2d_ms_array<T, a>>
  , _depth2d_ms_array_read<T, a>
{
  METAL_FUNC uint get_width() const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_ms_array<T, a> &>(*this);
    return __metal_get_width_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_height() const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_ms_array<T, a> &>(*this);
    return __metal_get_height_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_array_size() const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_ms_array<T, a> &>(*this);
    return __metal_get_array_size_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_ms_array<T, a> &>(*this);
    return __metal_get_num_samples_depth_2d_ms_array_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width() const device
  {
    const device auto &derived = static_cast<const device depth2d_ms_array<T, a> &>(*this);
    return __metal_get_width_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_height() const device
  {
    const device auto &derived = static_cast<const device depth2d_ms_array<T, a> &>(*this);
    return __metal_get_height_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_array_size() const device
  {
    const device auto &derived = static_cast<const device depth2d_ms_array<T, a> &>(*this);
    return __metal_get_array_size_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const device
  {
    const device auto &derived = static_cast<const device depth2d_ms_array<T, a> &>(*this);
    return __metal_get_num_samples_depth_2d_ms_array_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width() const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_ms_array<T, a> &>(*this);
    return __metal_get_width_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_height() const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_ms_array<T, a> &>(*this);
    return __metal_get_height_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_array_size() const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_ms_array<T, a> &>(*this);
    return __metal_get_array_size_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_ms_array<T, a> &>(*this);
    return __metal_get_num_samples_depth_2d_ms_array_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms_array<T, a> &>(*this);
    return __metal_get_width_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_height() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms_array<T, a> &>(*this);
    return __metal_get_height_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_array_size() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms_array<T, a> &>(*this);
    return __metal_get_array_size_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms_array<T, a> &>(*this);
    return __metal_get_num_samples_depth_2d_ms_array_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width() const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_ms_array<T, a> &>(*this);
    return __metal_get_width_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_height() const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_ms_array<T, a> &>(*this);
    return __metal_get_height_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_array_size() const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_ms_array<T, a> &>(*this);
    return __metal_get_array_size_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_ms_array<T, a> &>(*this);
    return __metal_get_num_samples_depth_2d_ms_array_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct depth2d_ms_array : _depth2d_ms_array<T, a>
{
  static_assert(is_depth_texture_channel<T>::value, "invalid channel type 'T' for 'depth2d_ms_array'");
  static_assert(_is_valid_depth_access(a), "invalid access value 'a' for 'depth2d_ms_array'");

  depth2d_ms_array() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  depth2d_ms_array() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  depth2d_ms_array() ray_data = delete;
#endif

  METAL_FUNC depth2d_ms_array(const thread depth2d_ms_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms_array(const device depth2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms_array(const constant depth2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const ray_data depth2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d_ms_array(const object_data depth2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms_array(const thread depth2d_ms_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms_array(const device depth2d_ms_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms_array(const constant depth2d_ms_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const ray_data depth2d_ms_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d_ms_array(const object_data depth2d_ms_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const thread depth2d_ms_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const device depth2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const constant depth2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const ray_data depth2d_ms_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const object_data depth2d_ms_array &) ray_data = default;
#endif
#endif

  thread depth2d_ms_array &operator=(const thread depth2d_ms_array &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread depth2d_ms_array &operator=(const device depth2d_ms_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread depth2d_ms_array &operator=(const constant depth2d_ms_array &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread depth2d_ms_array &operator=(const ray_data depth2d_ms_array &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread depth2d_ms_array &operator=(const object_data depth2d_ms_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depth2d_ms_array &operator=(const thread depth2d_ms_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depth2d_ms_array &operator=(const device depth2d_ms_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depth2d_ms_array &operator=(const constant depth2d_ms_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device depth2d_ms_array &operator=(const ray_data depth2d_ms_array &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device depth2d_ms_array &operator=(const object_data depth2d_ms_array &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_ms_array &operator=(const thread depth2d_ms_array &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_ms_array &operator=(const device depth2d_ms_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_ms_array &operator=(const constant depth2d_ms_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_ms_array &operator=(const ray_data depth2d_ms_array &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_ms_array &operator=(const object_data depth2d_ms_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data depth2d_ms_array &operator=(const thread depth2d_ms_array &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data depth2d_ms_array &operator=(const device depth2d_ms_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data depth2d_ms_array &operator=(const constant depth2d_ms_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data depth2d_ms_array &operator=(const ray_data depth2d_ms_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data depth2d_ms_array &operator=(const object_data depth2d_ms_array &) object_data = delete;
#endif

private:
  __metal_depth_2d_ms_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depth2d_ms_array<T, a>);
#endif
  friend struct _depth2d_ms_array_read<T, a>;
  friend struct _depth2d_ms_array<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct depth2d_ms_array<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _depth2d_ms_array<T, a>
{
  static_assert(is_depth_texture_channel<T>::value, "invalid channel type 'T' for 'depth2d_ms_array'");
  static_assert(_is_valid_depth_access(a), "invalid access value 'a' for 'depth2d_ms_array'");

  METAL_FUNC depth2d_ms_array() thread : t(__metal_get_null_depth_2d_ms_array_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms_array() constant : t(__metal_get_null_depth_2d_ms_array_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array() ray_data : t(__metal_get_null_depth_2d_ms_array_t()) {}
#endif

  METAL_FUNC depth2d_ms_array(const thread depth2d_ms_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms_array(const device depth2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms_array(const constant depth2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const ray_data depth2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d_ms_array(const object_data depth2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms_array(const thread depth2d_ms_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms_array(const device depth2d_ms_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms_array(const constant depth2d_ms_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const ray_data depth2d_ms_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d_ms_array(const object_data depth2d_ms_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const thread depth2d_ms_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const device depth2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const constant depth2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const ray_data depth2d_ms_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const object_data depth2d_ms_array &) ray_data = default;
#endif
#endif

  METAL_FUNC thread depth2d_ms_array &operator=(const thread depth2d_ms_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread depth2d_ms_array &operator=(const device depth2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread depth2d_ms_array &operator=(const constant depth2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread depth2d_ms_array &operator=(const ray_data depth2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread depth2d_ms_array &operator=(const object_data depth2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depth2d_ms_array &operator=(const thread depth2d_ms_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depth2d_ms_array &operator=(const device depth2d_ms_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depth2d_ms_array &operator=(const constant depth2d_ms_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device depth2d_ms_array &operator=(const ray_data depth2d_ms_array &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device depth2d_ms_array &operator=(const object_data depth2d_ms_array &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_ms_array &operator=(const thread depth2d_ms_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_ms_array &operator=(const device depth2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_ms_array &operator=(const constant depth2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_ms_array &operator=(const ray_data depth2d_ms_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_ms_array &operator=(const object_data depth2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_ms_array &operator=(const thread depth2d_ms_array &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_ms_array &operator=(const device depth2d_ms_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_ms_array &operator=(const constant depth2d_ms_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_ms_array &operator=(const ray_data depth2d_ms_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_ms_array &operator=(const object_data depth2d_ms_array &) object_data = default;
#endif

private:
  __metal_depth_2d_ms_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depth2d_ms_array<T, a>);
#endif
  friend struct _depth2d_ms_array_read<T, a>;
  friend struct _depth2d_ms_array<T, a>;
};
#endif
#endif

#if defined(__HAVE_NULL_TEXTURE__)
template <typename T, access a>
METAL_FUNC bool is_null_texture(texture1d<T, a> tex)
{
  return __metal_is_null_texture_1d_t(tex.t);
}
template <typename T, access a>
METAL_FUNC bool is_null_texture(texture1d_array<T, a> tex)
{
  return __metal_is_null_texture_1d_array_t(tex.t);
}
template <typename T, access a>
METAL_FUNC bool is_null_texture(texture2d<T, a> tex)
{
  return __metal_is_null_texture_2d_t(tex.t);
}
template <typename T, access a>
METAL_FUNC bool is_null_texture(texture2d_array<T, a> tex)
{
  return __metal_is_null_texture_2d_array_t(tex.t);
}
template <typename T, access a>
METAL_FUNC bool is_null_texture(texture3d<T, a> tex)
{
  return __metal_is_null_texture_3d_t(tex.t);
}
template <typename T, access a>
METAL_FUNC bool is_null_texture(texturecube<T, a> tex)
{
  return __metal_is_null_texture_cube_t(tex.t);
}
#if defined(__HAVE_TEXTURE_CUBE_ARRAY__)
template <typename T, access a>
METAL_FUNC bool is_null_texture(texturecube_array<T, a> tex)
{
  return __metal_is_null_texture_cube_array_t(tex.t);
}
#endif
template <typename T, access a>
METAL_FUNC bool is_null_texture(texture2d_ms<T, a> tex)
{
  return __metal_is_null_texture_2d_ms_t(tex.t);
}
#if defined(__HAVE_TEXTURE_2D_MS_ARRAY__)
template <typename T, access a>
METAL_FUNC bool is_null_texture(texture2d_ms_array<T, a> tex)
{
  return __metal_is_null_texture_2d_ms_array_t(tex.t);
}
#endif
#if defined(__HAVE_TEXTURE_BUFFER__)
template <typename T, access a>
METAL_FUNC bool is_null_texture(texture_buffer<T, a> tex)
{
  return __metal_is_null_texture_buffer_1d_t(tex.t);
}
#endif
template <typename T, access a>
METAL_FUNC bool is_null_texture(depth2d<T, a> tex)
{
  return __metal_is_null_depth_2d_t(tex.t);
}
template <typename T, access a>
METAL_FUNC bool is_null_texture(depth2d_array<T, a> tex)
{
  return __metal_is_null_depth_2d_array_t(tex.t);
}
template <typename T, access a>
METAL_FUNC bool is_null_texture(depthcube<T, a> tex)
{
  return __metal_is_null_depth_cube_t(tex.t);
}
#if defined(__HAVE_DEPTH_CUBE_ARRAY__)
template <typename T, access a>
METAL_FUNC bool is_null_texture(depthcube_array<T, a> tex)
{
  return __metal_is_null_depth_cube_array_t(tex.t);
}
#endif
template <typename T, access a>
METAL_FUNC bool is_null_texture(depth2d_ms<T, a> tex)
{
  return __metal_is_null_depth_2d_ms_t(tex.t);
}
#if defined(__HAVE_DEPTH_2D_MS_ARRAY__)
template <typename T, access a>
METAL_FUNC bool is_null_texture(depth2d_ms_array<T, a> tex)
{
  return __metal_is_null_depth_2d_ms_array_t(tex.t);
}
#endif
#endif
} // namespace metal
#pragma METAL internals : disable

#endif // __METAL_TEXTURE
